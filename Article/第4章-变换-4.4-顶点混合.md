## 4.4 顶点混合
想象一下，数字角色的手臂使用两部分动画制作，前臂和上臂，如图4.11左侧所示。该模型可以使用刚体变换进行动画处理（[第4.1.6节][netlink4.1]）。但是，这两个部分之间的关节将不会像真正的肘部。这是因为使用了两个单独的对象，因此，关节由这两个单独对象的重叠部分组成。显然，最好只使用一个对象。然而，静态模型部件并没有解决使关节灵活的问题。

<div align = "center">

![Figure4.11]

</div>

<div align = "center">

**图4.11**. 由前臂和上臂组成的手臂使用左侧两个独立对象的刚体变换进行动画处理。肘部看起来不真实。在右侧，顶点混合用于单个对象。最右边的手臂说明了当一个简单的皮肤直接连接两个部分以覆盖肘部时会发生什么。最右边的手臂说明了使用顶点混合时会发生什么，一些顶点混合了不同的权重：(2/3,1/3) 表示顶点将上臂的变换权重为2/3，前臂的权重为1/3。该图还在最右侧的图中显示了顶点混合的缺点。在这里，可以看到肘部内部的折叠。使用更多的骨骼和更仔细选择的权重可以获得更好的结果。

</div>

顶点混合是该问题的一种流行解决方案[1037, 1903]。这种技术还有其他几个名称，例如线性混合蒙皮、包络或骨骼子空间变形。虽然此处介绍的算法的确切起源尚不清楚，但定义骨骼和让皮肤对变化做出反应是计算机动画中的一个古老概念[1100]。在最简单的形式中，前臂和上臂像以前一样分开动画，但在关节处，这两个部分通过弹性“皮肤”连接。所以，这个弹性部分将有一组由前臂矩阵变换的顶点和另一组由上臂矩阵变换的顶点。与每个三角形使用单个矩阵形成对比的是：三角形的顶点可以由不同的矩阵转换。参见图4.11。

通过更进一步，可以允许单个顶点被几个不同的矩阵转换，结果位置被加权并混合在一起。这是通过为动画对象设置骨骼骨架来完成的，其中每个骨骼的变换可能会通过用户定义的权重影响每个顶点。由于整个手臂可能是“弹性的”，即所有顶点都可能受到多个矩阵的影响，因此整个网格通常称为皮肤（在骨骼上）。见图 4.12。许多商业建模系统都具有这种相同的骨架-骨骼建模功能。尽管他们的名字，骨头不一定是刚性的。例如，Mohr和Gleicher[1230]提出了添加额外关节以实现诸如肌肉隆起等效果的想法。James和Twigg[813]讨论了使用可以挤压和拉伸的骨骼的动画蒙皮。

<div align = "center">

![Figure4.12]

</div>

<div align = "center">

**图4.12**.  顶点混合的真实示例。左上角的图像显示了手臂的两块骨头，处于伸展位置。在右上角，显示了网格，颜色表示哪个骨骼拥有的每个顶点。底部：手臂的阴影网格在一个稍微不同的位置。（图片由Jeff Lander[968]提供。）

</div>

在数学上，这用公式4.59表示，其中$\textbf{p}$是原始顶点，而$\textbf{u}(t)$是变换后的顶点，其位置取决于时间$t$：
$$
\textbf{u}(t) = \sum_{i=0}^{n-1}w_i\textbf{B}_i(t)\textbf{M}_i^{-1}\textbf{p}, \quad where \quad \sum_{i=0}^{n-1}w_i = 1, \quad w_i\geq0 \tag{4.59} 
$$

有n个骨骼影响$\textbf{p}$的位置，其用世界坐标表示。值$w_i$是顶点$\textbf{p}$的骨骼$i$的权重。矩阵$\textbf{M}_i$从初始骨骼坐标系转换为世界坐标系。通常，骨骼的控制关节位于其坐标系的原点。例如，前臂骨骼会将其肘关节移动到原点，动画旋转矩阵会围绕关节移动手臂的这一部分。$\textbf{B}_i(t)$矩阵是第$i$个骨骼的世界变换，它随时间变化以使对象动画化，并且通常是几个矩阵的级联，例如先前骨骼变换的层次结构和局部动画矩阵。

Woodland[1903]深入讨论了一种维护和更新$\textbf{B}_i(t)$矩阵动画函数的方法。每个骨骼将一个顶点转换为相对于它自己的参考系的位置，并且最终位置是从一组计算点中插入的。矩阵$\textbf{M}_i$在一些蒙皮的讨论中没有明确显示，而是被认为是$\textbf{B}_i(t)$的一部分。我们在这里介绍它是因为它是一个有用的矩阵，几乎总是矩阵级联过程的一部分。

在实践中，矩阵$\textbf{B}_i(t)$和$\textbf{M}_i^{-1}$通过为动画的每一帧的每个骨骼级联，将每个结果矩阵用于变换顶点。顶点$\textbf{p}$由不同骨骼的级联矩阵转换，然后使用权重$w_i$进行混合——因此称为顶点混合。权重是非负的并且总和为1，因此实际上是将顶点转换为几个位置，然后在它们之间进行插值。因此，对于所有$i = 0...n − 1$（固定 t），变换后的点$\textbf{u}$将位于点集$\textbf{B}_i(t)\textbf{M}_i^{-1}\textbf{p}$的凸包中。法线通常也可以使用公式4.59进行转换。根据所使用的变换（例如，如果骨骼被拉伸或压扁相当多），可能需要对 $\textbf{B}_i(t)\textbf{M}_i^{-1}$的逆进行转置，如[第4.1.7节][netlink4.1]所述。

顶点混合非常适合在GPU上使用。网格中的一组顶点可以放置在一个静态缓冲区中，该缓冲区一次发送到GPU并重复使用。在每一帧中，只有骨骼矩阵发生变化，顶点着色器会计算它们对存储网格的影响。通过这种方式，在CPU上处理和传输的数据量被最小化，允许GPU有效地渲染网格。如果模型的整套骨骼矩阵可以一起使用，则最简单；否则必须拆分模型并复制一些骨骼。或者，骨骼变换可以存储在顶点访问的纹理中，这避免了达到寄存器存储限制。通过使用四元数来表示旋转，每个变换可以存储在两个纹理中[1639]。如果可用，无序访问视图存储允许重用蒙皮的结果[146]。

可以指定超出范围[0,1]或总和不为1的权重集。但是，这仅在使用其他混合算法，例如变形目标（[第4.5节][netlink4.5]）时才有意义。

基本顶点混合的一个缺点是可能会发生不需要的折叠、扭曲和自相交 [1037]。见图4.13。更好的解决方案是使用双四元数[872,873]。这种执行蒙皮的技术有助于保持原始变换的刚性，从而避免四肢中的“糖果包装纸”扭曲。其计算小于线性皮肤混合代价的1.5倍，但是效果很好，这导致该技术被迅速采用。然而，双四元数蒙皮会导致膨胀效应，Le和Hodgins[1001]提出了旋转中心蒙皮作为更好的选择。它们依赖于这样的假设：局部变换应该是刚体，并且具有相似权重$w_i$的顶点应该具有相似的变换形式。为每个顶点预先计算旋转中心，同时施加正交（刚体）约束以防止肘部塌陷和糖果包装扭曲假像。在运行时，该算法类似于线性混合蒙皮，因为GPU实现了在旋转中心执行线性混合蒙皮，然后是四元数混合步骤。

<div align = "center">

![Figure4.13]

</div>

<div align = "center">

**图4.13**. 左侧显示了使用线性混合蒙皮时关节处的问题。在右侧，使用双四元数进行混合改善了外观。（图片由Ladislav Kavan等人提供，由Paul Steed [1693]建模。）

</div>


[Figure4.11]:Figure/Figure4.11.JPG
[Figure4.12]:Figure/Figure4.12.JPG
[Figure4.13]:Figure/Figure4.13.JPG

[netlink4.1]:https://github.com/fafa1899/RTR-4-CN/blob/main/Pdf/第4章-变换-4.1-基础变换.pdf
[netlink4.5]:netlink4.5