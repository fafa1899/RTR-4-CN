## 5.1 着色模型

确定渲染对象外观的第一步是选择着色模型来描述对象的颜色应如何根据表面方向、视图方向和光照等因素变化。

例如，我们将使用Gooch着色模型[561]的变体。这是非真实感渲染的一种形式，是[第15章][netlink15.0]的主题。Gooch着色模型旨在提高技术插图中细节的易读性。

Gooch着色背后的基本思想是将表面法线与光的位置进行比较。如果法线指向光线，则使用较暖的色调为表面着色；如果它指向远处，则使用较冷的音调。之间的角度在这些色调之间进行插值，这些色调基于用户提供的表面颜色。在本例中，我们向模型添加了风格化的“高光”效果，使表面具有闪亮的外观。图5.2显示了正在运行的着色模型。

<div align = "center">

![Figure5.2]

</div>

<div align = "center">

**图5.2**. 结合Gooch着色和高光效果的风格化着色模型。上图显示了一个具有中性表面颜色的复杂对象。下图显示了具有各种不同表面颜色的球体。 （来自Computer Graphics Archive[1172]的中国龙网格，来自斯坦福3D扫描存储库的原始模型。）

</div>

着色模型通常具有用于控制外观变化的属性。设置这些属性的值是确定对象外观的下一步。我们的示例模型只有一个属性，即表面颜色，如图5.2的底部图像所示。

与大多数着色模型一样，此示例受相对于视图和光照方向的表面方向的影响。出于着色目的，这些方向通常表示为归一化（单位长度）向量，如图5.3所示。

<div align = "center">

![Figure5.3]

</div>

<div align = "center">

**图5.3**. 示例着色模型（以及大多数其他模型）的单位长度向量输入：表面法线$\textbf{n}$、视图向量$\textbf{v}$和光方向$\textbf{l}$。

</div>

现在我们已经定义了着色模型的所有输入，我们可以看看模型本身的数学定义：
$$
\textbf{c}_\textrm{shaded} = s\textbf{c}_\textrm{highlight} + (1 − s)(t\textbf{c}_\textrm{warm} + (1 − t)c_\textrm{cool})
\tag{5.1}
$$

在这个等式中，我们使用了以下中间计算：
$$
\begin{aligned}
\textbf{c}_\textrm{cool} &= (0,0,0.55) + 0.25\textbf{c}_\textrm{surface} \\
\textbf{c}_\textrm{warm} &= (0.3,0.3,0) + 0.25\textbf{c}_\textrm{surface} \\
\textbf{c}_\textrm{highlight} &= (1,1,1) \\
t &= \frac{(\textbf{n} \cdot \textbf{l}) + 1}{2}\\
\textbf{r} &= 2(\textbf{n} · \textbf{l})\textbf{n} − \textbf{l} \\
s &= (100(\textbf{r} \cdot \textbf{v}) − 97)^{\mp} \\
\end{aligned}
$$

此定义中的几个数学表达式也经常出现在其他着色模型中。钳位操作，通常钳位到0或钳位到0和1之间，在着色中很常见。在这里，我们使用[第1.2节][netlink1.2]中介绍的$x^{\mp}$表示法，用于计算高光混合因子$s$中使用的0和1之间的钳位。点积运算符出现3次，每次出现在两个单位长度向量之间；这是一种极为常见的方式。两个向量的点积是它们的长度和它们之间夹角的余弦的乘积。因此，两个单位长度向量的点积就是余弦，这是衡量两个向量相互对齐程度的有用度量。由余弦组成的简单函数通常是解释着色模型中两个方向（例如光方向和表面法线）之间关系的最令人满意和最准确的数学表达式。


另一种常见的着色操作是基于0和1之间的标量值在两种颜色之间进行线性插值。此运算采用$t\textbf{c}_a + (1 − t)\textbf{c}_b$的形式，当$t$的值分别在1和0之间移动时，它会在$\textbf{c}_a$和$\textbf{c}_b$之间进行插值。这种模式在这个着色模型中出现了两次，第一次在$\textbf{c}_\textrm{warm}$和$\textbf{c}_\textrm{cool}$之间进行插值，第二次在前一次插值的结果和$\textbf{c}_\textrm{highlight}$之间进行插值。线性插值经常出现在着色器中，以至于在我们见过的每种着色语言中，它都是一个内置函数，称为$\textrm{lerp}$或$\textrm{mix}$。

行“$\textbf{r} = 2(\textbf{n} · \textbf{l})\textbf{n} − \textbf{l}$”计算反射光向量，基于$\textbf{n}$反射$\textbf{l}$。虽然不像前两个操作那么常见，但大多数着色语言具有的内置的reflect函数足以应对这种情况。

通过以不同方式将此类操作与各种数学表达式和着色参数相结合，可以为种类繁多的风格化和写实的外观定义着色模型。


[Figure5.2]:Figure/Figure5.2.JPG
[Figure5.3]:Figure/Figure5.3.JPG

[netlink1.2]:[netlink1.2]
[netlink15.0]:netlink15.0