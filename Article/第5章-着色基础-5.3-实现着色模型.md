## 5.3 实现着色模型

出于实用目的，这些着色和光照方程当然必须在代码中实现。在本节中，我们将讨论设计和编写此类实现的一些关键考虑因素。我们还将介绍一个简单的实现示例。

### 5.3.1 计算频率

在设计着色实现时，计算需要根据其计算频率进行划分。首先，确定给定计算的结果在整个绘制调用中是否始终不变。在这种情况下，计算可以由应用程序执行，通常在CPU上执行，尽管GPU计算着色器可用于特别昂贵的计算。结果通过标准着色器输入传递给图形API。

即使在这一类别中，也有广泛的可能计算频率，从“曾经一次”开始。这种情况最简单的就是是着色方程中的常量子表达式，但这可以应用于基于很少变化的因素（例如硬件配置和安装选项）的任何计算。在编译着色器时可能会解决此类着色计算，在这种情况下甚至不需要设置着色器的统一(uniform)输入。或者，可以在离线预计算阶段、安装时或加载应用程序时执行计算。

另一种情况是当应用程序运行时着色计算的结果发生变化，但速度太慢以至于不需要每帧更新它。例如，取决于虚拟游戏世界中一天中时间的照明因素。如果计算成本很高，则可能值得将其分摊到多个帧上。

其他情况包括每帧执行一次的计算，例如级联视图和透视矩阵；或每个模型一次，例如更新取决于位置的模型的照明参数；或者每次绘制调用一次，例如，更新模型中每种材质的参数。按计算频率对统一(uniform)着色器输入进行分组，有助于提高应用程序效率，并且还可以通过最小化持续更新来提高GPU性能 [1165]。

如果着色计算的结果在绘制调用中发生变化，则无法通过统一(uniform)着色器输入将其传递给着色器。相反，它必须由[第3章][netlink3.0]中描述的可编程着色器阶段之一进行计算，并在需要时通过不同的着色器输入传递给其他阶段。理论上，可以在任何可编程阶段执行着色计算，每个阶段对应不同的计算频率：

* 顶点着色器——逐预细分顶点计算。
* 外壳着色器——逐表面片元计算。
* 域着色器——逐细分后顶点的计算。
* 几何着色器——逐图元计算。
* 像素着色器——逐像素计算。

在实践中，大多数着色计算都是逐像素执行的。虽然这些通常在像素着色器中实现，但计算着色器实现越来越普遍；[第 20章][netlink20.0]将讨论几个例子。其他阶段主要用于几何运算，例如变换和变形。为了理解为什么会这样，我们将比较逐顶点和逐像素着色计算的结果。在较早的文本中，这些有时分别称为Gouraud着色[578]和Phong着色[1414]，尽管这些术语在今天并不常用。此比较使用的着色模型与公式5.1中的模型有些相似，但经过修改以适用于多个光源。稍后将在我们详细介绍示例实现时给出完整的模型。

图5.9显示了在具有广泛顶点密度的模型上的逐像素和逐顶点着色的结果。对于龙来说，一个极其密集的网格，两者之间的差异很小。但是在茶壶上，顶点着色计算会导致可见的错误，例如角形高光，而在两个三角形平面上，顶点着色版本显然是不正确的。这些错误的原因是着色方程的某些部分，特别是高光部分，具有在网格表面上非线性变化的值。这使得它们不适合顶点着色器，其结果在被传递到像素着色器之前在三角形上线性插值。

<div align = "center">

![Figure5.9]

</div>

<div align = "center">

**图5.9**. 公式5.19中示例着色模型的逐像素和逐顶点计算的比较，显示在三个不同顶点密度的模型上。左列显示逐像素计算的结果，中列显示逐顶点计算，右列显示每个模型的线框渲染以显示顶点密度。（来自计算机图形档案[1172]的中国龙网格，斯坦福3D扫描存储库的原始模型。）

</div>

原则上，可以在像素着色器中仅计算着色模型的镜面高光部分，并在顶点着色器中计算其余部分。这可能不会导致视觉伪影，理论上会节省一些计算量。在实践中，这种混合实现通常不是最优的。着色模型的线性变化部分往往是计算成本最低的，并且以这种方式拆分着色计算往往会增加足够的开销，例如重复计算和额外的变化输入，足以抵消任何好处。

正如我们前面提到的，在大多数实现中，顶点着色器负责非着色操作，例如几何变换和变形。生成的几何表面属性，转换为适当的坐标系，由顶点着色器写出，在三角形上线性插值，并作为不同的着色器输入传递到像素着色器。这些属性通常包括曲面的位置、曲面法线以及可选的曲面切线向量（如果需要进行法线映射）。


请注意，即使顶点着色器总是生成单位长度的表面法线，插值也可以改变它们的长度。请参见图5.10的左侧。出于这个原因，法线需要在像素着色器中重新归一化（缩放到长度 1）。但是，顶点着色器生成的法线长度仍然很重要。如果顶点之间的法线长度变化很大，例如，作为顶点混合的副作用，这将扭曲插值。这可以在图5.10的右侧看到。由于这两种影响，实现通常在插值之前和之后对插值向量进行归一化，即在顶点和像素着色器中。

<div align = "center">

![Figure5.10]

</div>

<div align = "center">

**图5.10**. 在左边，我们看到跨表面的单位法线的线性插值导致长度小于1的插值向量。在右侧，我们看到长度明显不同的法线的线性插值导致插值方向偏向两条法线中较长的一条。

</div>

与表面法线不同，指向特定位置的向量（例如精确光源的视图向量和光向量）通常不会被插值。相反，插值的表面位置用于在像素着色器中计算这些向量。除了归一化（正如我们所见，在任何情况下都需要在像素着色器中执行）之外，这些向量中的每一个都是通过向量减法计算的，这很快。如果由于某种原因需要对这些向量进行插值，请不要事先对它们进行归一化。这将产生不正确的结果，如图5.11所示。

<div align = "center">

![Figure5.11]

</div>

<div align = "center">

**图5.11**. 两个光向量之间的插值。在左侧，插值前对其进行归一化会导致插值后方向不正确。在右侧，对非归一化向量进行插值会产生正确的结果。

</div>

前面我们提到顶点着色器将表面几何转换为“适当的坐标系”。通过统一(uniform)变量传递给像素着色器的相机和灯光位置通常由应用程序转换到相同的坐标系中。这最大限度地减少了像素着色器所做的工作，以将所有着色模型向量带入相同的坐标空间。但是哪个坐标系是“合适的”？可能性包括全局世界空间以及相机的局部坐标系，或者更少见的是当前渲染模型的局部坐标系。通常基于系统考虑（例如性能、灵活性和简单性）对整个渲染系统进行选择。例如，如果渲染场景预计包含大量灯光，则可以选择世界空间以避免变换灯光位置。或者，相机空间可能是首选，以更好地优化与视图向量相关的像素着色器操作并可能提高精度（[第16.6节][netlink16.6]）。

尽管大多数着色器实现，包括我们将要讨论的示例实现，都遵循上面描述的一般大纲，但当然也有例外。例如，出于风格化的原因，某些应用程序选择逐图元着色计算的面外观。这种风格通常被称为平面着色。图5.12显示了两个示例。


<div align = "center">

![Figure5.12]

</div>

<div align = "center">

**图5.12**. 使用平面着色作为风格选择的两款游戏：《肯德基0号路》,上图和《癌症似龙》，底部。（上图由 Cardboard Computer提供，下图由Numinous Games提供。）

</div>

原则上，平面着色可以在几何着色器中执行，但最近的实现通常使用顶点着色器。这是通过将每个图元的属性与其第一个顶点相关联并禁用顶点值插值来完成的。禁用插值（可以分别为每个顶点值完成）导致来自第一个顶点的值传递给图元中的所有像素。

### 5.3.2 Implementation Example



### 5.3.3 Material Systems

[netlink3.0]:netlink3.0
[netlink16.6]:netlink16.6
[netlink20.0]:netlink20.0

[Figure5.9]:Figure/Figure5.9.JPG
[Figure5.10]:Figure/Figure5.10.JPG
[Figure5.11]:Figure/Figure5.11.JPG
[Figure5.12]:Figure/Figure5.12.JPG

