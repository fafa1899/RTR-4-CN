## 5.5 透明度、Alpha和合成

半透明物体可以通过多种不同的方式让光线穿过它们。对于渲染算法，这些可以大致分为基于光照和基于视图的效果。 基于光的效果是指对象导致光线衰减或转向，从而导致场景中的其他对象以不同方式被照亮和渲染的效果。基于视图的效果是呈现半透明对象本身的效果。

在本节中，我们将处理基于视图的最简单形式的透明度，其中半透明对象充当其后面对象颜色的衰减器。后续章节将讨论更精细的基于视图和基于光的效果，例如毛玻璃、光的弯曲（折射）、由于透明物体的厚度导致的光衰减，以及由于视角导致的反射率和透射率变化。

一种产生透明错觉的方法称为纱门透明[1244]。这个想法是用像素对齐的棋盘填充图案来渲染透明三角形。也就是说，三角形的每个其他像素都会被渲染，从而使其后面的对象部分可见。通常屏幕上的像素足够靠近，以至于棋盘图案本身是不可见的。这种方法的一个主要缺点是通常只有一个透明对象可以令人信服地呈现在屏幕的一个区域上。例如，如果在蓝色对象上渲染透明红色对象和透明绿色对象，则在棋盘图案上只能出现三种颜色中的两种。此外，50%的棋盘格是有限的。其他较大的像素掩码可用于给出其他百分比，但这些往往会产生可检测的图案[1245]。

也就是说，这种技术的一个优点是它的简单性。透明对象可以在任何时间以任何顺序渲染，不需要特殊的硬件。透明度问题在所有对象在它们覆盖的像素处不透明时消失。同样的想法也用于剪切纹理的抗锯齿边缘，但在亚像素级别，使用称为覆盖范围的alpha功能（[第6.6节][netlink6.6]）。

Enderton等人[423]介绍了随机透明度使用亚像素纱门掩码与随机采样相结合。通过使用随机点画图案来表示片段的alpha覆盖范围，可以创建一个合理但附带噪声的图像。请参见图5.31。每个像素需要大量样本才能使结果看起来合理，并且所有子像素样本需要大量内存。吸引人的是不需要混合，抗锯齿、透明度和任何其他产生部分覆盖像素的现象都由单一机制覆盖。

<div align = "center">

![Figure5.31]

</div>

<div align = "center">

**图5.31**. 随机透明度。产生的噪声显示在放大区域中。（图片来自NVIDIA SDK 11[1301]样本，由NVIDIA Corporation提供。）

</div>

大多数透明度算法将透明对象的颜色与其后面对象的颜色混合。为此，需要alpha混合的概念[199,387,1429]。当在屏幕上渲染对象时，RGB颜色和z-buffer深度与每个像素相关联。另一个组件，称为alpha(α)，也可以为对象覆盖的每个像素定义。Alpha是描述给定像素的对象片段的不透明度和覆盖程度的值。alpha为1.0意味着对象是不透明的，并且完全覆盖了像素的感兴趣区域；0.0表示像素完全没有被遮挡，即片段是完全透明的。

根据具体情况，像素的alpha可以表示不透明度、覆盖率或两者兼而有之。例如，肥皂泡的边缘可能覆盖四分之三的像素，即0.75，并且可能几乎是透明的，让十分之九的光线通过眼睛，所以它是不透明的十分之一，即0.1。那么它的alpha将为0.75 × 0.1 = 0.075。但是，如果我们使用MSAA或类似的抗锯齿方案，则样本本身将考虑覆盖范围。四分之三的样本会受到肥皂泡的影响。在每个样本中，我们将使用0.1的不透明度值作为alpha。

### 5.5.1 混合顺序

为了使对象看起来透明，它会在现有场景的顶部以小于1.0的alpha进行渲染。对象覆盖的每个像素都将接收来自像素着色器的结果RGBα（也称为 RGBA）。将此片段的值与原始像素颜色混合通常使用$\textbf{over}$运算符完成，如下所示：
$$
\textbf{c}_o = \alpha_s\textbf{c}_s + (1 − α_s)\textbf{c}_d \ \ [\textbf{over}\ \textrm{operator}] \tag{5.24}
$$

其中$\textbf{c}_s$是透明对象（称为源）的颜色，$α_s$是对象的alpha，$\textbf{c}_d$是之前的像素颜色混合（称为目标），$\textbf{c}_o$是由于将透明对象放置在现有场景上而产生的颜色。在渲染管道发送$\textbf{c}_s$和$α_s$的情况下，像素的原始颜色$\textbf{c}_d$被结果$\textbf{c}_o$替换。如果输入的RGBα实际上是不透明的$(α_s = 1.0)$，则方程简化为用对象的颜色完全替换像素的颜色。

**示例：混合**。红色半透明对象被渲染到蓝色背景上。假设在某个像素处，对象的RGB着色为$(0.9,0.2,0.1)$，背景为$(0.1,0.1,0.9)$，对象的不透明度设置为$0.6$。这两种颜色的混合将是
$$
0.6(0.9,0.2,0.1) + (1 − 0.6)(0.1,0.1,0.9),
$$

它给出的颜色为$(0.58,0.16,0.42)$。

$\textbf{over}$运算符为正在渲染的对象提供半透明的外观。以这种方式完成的透明度是有效的，在某种意义上，只要可以通过它看到后面的对象，我们就会认为某物是透明的[754]。可以使用$\textbf{over}$模拟薄纱织物的真实效果。织物后面的物体的视野被部分遮挡——织物的线是不透明的。在实践中，松散的织物具有随角度变化的alpha覆盖率[386]。我们的观点是，alpha模拟了材质覆盖像素的程度。

$\textbf{over}$操作符在模拟其他透明效果时不太令人信服，尤其是通过彩色玻璃或塑料观看时。在现实世界中，在蓝色物体前面放置一个红色滤光片通常会使蓝色物体看起来很暗，因为这个物体反射的光线很少可以通过红色滤光片。请参见图5.32。当使用$\textbf{over}$进行混合时，结果是红色和蓝色的一部分相加在一起。最好将两种颜色相乘，并添加透明物体本身的任何反射。这种类型的物理透射率在[第14.5.1节][netlink14.5]和[第14.5.2节][netlink14.5]中讨论。


<div align = "center">

![Figure5.32]

</div>

<div align = "center">

**图5.32**. 一块红色薄纱方形织物和一个红色塑料过滤器，提供不同的透明度效果。注意阴影也不同。（照片由摩根麦奎尔提供。）

</div>

在基本的混合阶段运算符中，$\textbf{over}$是一种常用于透明效果的运算符[199,1429]。另一种有用的操作是加法混合，其中像素值只是简单地相加。也就是说:
$$
\textbf{c}_o = α_s\textbf{c}_s + \textbf{c}_d \tag{5.25}
$$

这种混合模式可以很好地用于发光效果，例如闪电或火花，它们不会衰减后面的像素，而只会使它们变亮[1813]。但是，这种模式对于透明度来说看起来并不正确，因为不透明的表面看起来没有被过滤[1192]。对于几个分层的半透明表面，例如烟或火，加法混合具有使现象的颜色饱和的效果[1273]。

为了正确渲染透明对象，我们需要在不透明对象之后绘制它们。这是通过首先渲染所有不透明对象并关闭混合，然后渲染透明对象并开启混合来完成的。从理论上讲，我们还可以继续绘制，因为1.0的不透明alpha会给出源颜色并隐藏目标颜色，但这样做会更昂贵，而且没有真正的收益。

z缓冲区的一个限制是每个像素只能存储一个对象。如果多个透明对象与同一个像素重叠，则单独的z缓冲区无法容纳并在以后解决所有可见对象的效果。在任何给定像素的透明表面上使用时，通常需要按从后到前的顺序进行渲染。不这样做会给出不正确的感知提示。实现这种排序的一种方法是对单个对象进行排序，例如，根据它们的质心沿视图方向的距离排序。这种粗略的排序可以很好地工作，但在各种情况下都有许多问题。首先，顺序只是一个近似值，因此被归类为更远的对象可能位于被认为更近的对象之前。对于所有视角，互穿的对象不可能在每个网格的基础上解析，除非将每个网格分成单独的部分。有关示例，请参见图5.33中的左图。即使是具有凹面的单个网格也会在屏幕上重叠的视图方向出现排序问题。

<div align = "center">

![Figure5.33]

</div>

<div align = "center">

**图5.33**. 在左侧，模型使用z缓冲区以透明度进行渲染。以任意顺序渲染网格会产生严重错误。在右侧，深度剥离提供了正确的外观，但代价是额外的(深度)通过(检测)。（图片由英伟达公司提供。）

</div>

尽管如此，由于它的简单性和速度，以及不需要额外的内存或特殊的GPU支持，仍然普遍使用对透明度进行粗略排序。如果实施，通常最好在执行透明度时关闭z深度替换。即z-buffer仍然正常测试，但是幸存的表面并没有改变存储的z-depth；最近的不透明表面的深度保持不变。这样，所有透明物体至少会以某种形式出现，而不是在相机旋转改变排序顺序时突然出现或消失。其他技术也可以帮助改善外观，例如每次绘制每个透明网格两次，首先渲染背面，然后渲染正面[1192,1255]。

也可以修改$\textbf{over}$方程，以便从前到后混合得到相同的结果。这种混合模式称为$\textbf{under}$运算符：
$$
\begin{aligned}
\textbf{c}_o &= \alpha_d\textbf{c}_d + (1 − \alpha_d)\alpha_s\textbf{c}_s \ \ [\textbf{under}\ \textrm{operator}] \\
\textbf{a}_o &= \alpha_s (1 − \alpha_d ) + \alpha_d = \alpha_s − \alpha_s\alpha_d + \alpha_d \\
\end{aligned}
\tag{5.26}
$$

请注意，$\textbf{under}$要求目标保持alpha值，而$\textbf{over}$则不需要。换句话说，目标——被混合的更接近透明的表面——不是不透明的，因此需要有一个alpha值。$\textbf{under}$公式就像$\textbf{over}$，但是交换了源和目标。此外，请注意计算alpha的公式与顺序无关，因为可以交换源alpha和目标alpha，得到结果相同的最终alpha。

alpha的方程来自将片段的alpha视为覆盖范围。Porter和Duff[1429]注意到，由于我们不知道任一片元的覆盖区域的形状，我们假设每个片元都与其alpha成比例地覆盖另一个片元。例如，如果$α_s = 0.7$，则像素以某种方式分为两个区域，其中$0.7$被源片段覆盖，而$0.3$则没有。除非有任何其他知识，否则覆盖$α_d = 0.6$的目标片段将按比例与源片段重叠。这个公式有一个几何解释，如图5.34所示。

<div align = "center">

![Figure5.34]

</div>

<div align = "center">

**图5.34**. 一个像素和两个片段，$s$和$d$。通过沿不同的轴对齐两个片元，每个片元覆盖另一个片元的比例量，即它们是不相关的。两个片元覆盖的区域相当于$\textbf{under}$输出的alpha值$α_s - α_s α_d + α_d$。这意味着将两个区域相加，然后减去它们重叠的区域。

</div>

### 5.5.2 顺序无关透明

通过将所有透明对象绘制到单独的颜色缓冲区来使用$\textbf{under}$方程，然后使用$\textbf{over}$将此颜色缓冲区合并到场景的不透明视图顶部。$\textbf{under}$运算符的另一个用途是执行已知的与顺序无关的透明度(OIT)算法作为深度剥离[449,1115]。顺序无关意味着应用程序不需要执行排序。深度剥离背后的想法是使用两个z缓冲区和多个通道。首先，进行渲染通道，以便所有表面的z深度，包括透明表面，都在第一个z缓冲区中。在第二遍中，所有透明对象都被渲染。如果对象的z深度与第一个z缓冲区中的值匹配，我们就知道这是最近的透明对象，并将其RGBα保存到单独的颜色缓冲区中。我们还通过保存超出第一个z深度并且最接近的任何透明对象（如果有）的z深度来“剥离”该层。此z深度是第二近的透明对象的距离。连续的通道使用$\textbf{under}$继续剥离和添加透明层。我们在经过一定次数的通道后停止，然后在不透明图像上混合透明图像。请参见图5.35。

<div align = "center">

![Figure5.35]

</div>

<div align = "center">

**图5.35**. 每个深度剥离通道绘制透明层之一。左边是第一遍，显示了肉眼直接可见的图层。中间显示的第二层显示每个像素处第二近的透明表面，在本例中为对象的背面。右侧的第三层是一组第三近的透明表面。最终结果可在第624页的图14.33中找到。（图片由Louis Bavoil提供。）

</div>

已经开发了该方案的几种变体。例如，Thibieroz[1763]给出了一种从后向前工作的算法，它的优点是能够立即混合透明值，这意味着不需要单独的Alpha通道。深度剥离的一个问题是知道多少遍足以捕获所有透明层。一种硬件解决方案是提供一个像素绘制计数器，它告诉渲染期间写入了多少像素；当通道没有渲染像素时，渲染完成。使用$\textbf{under}$的优势在于，最重要的透明层——眼睛首先看到的层——在早期就被渲染了。每个透明表面总是增加它所覆盖的像素的alpha值。如果像素的alpha值接近1.0，则混合贡献使像素几乎不透明，因此更远的物体将产生可忽略不计的影响[394]。当通道渲染的像素数量低于某个最小值时，可以中断从前到后的剥离(的过程)，当然也可以使用指定固定数量的通道的办法。这不适用于从后到前的剥离，因为最近的（通常是最重要的）层是最后绘制的，因此可能会因提前终止而丢失。

虽然深度剥离很有效，但它可能会很慢，因为剥离的每一层都是所有透明对象的单独渲染通道。Bavoil和Myers[118] 提出了双深度剥离，其中两个深度剥离层，最近的和最远的，在每个通道中被剥离，从而将渲染通道的数量减少了一半。刘等人[1056]探索一种桶排序方法，该方法在一次通道中捕获多达32层。这种方法的一个缺点是它需要大量内存来保持所有层的排序顺序。通过MSAA或类似方法进行抗锯齿会大大增加成本。

以交互速率将透明对象正确混合在一起的问题不是我们缺乏算法的问题，而是将这些算法有效地映射到GPU的问题之一。1984年，Carpenter提出了A-buffer[230]，这是另一种多重采样形式。在A缓冲区中，每个渲染的三角形都会为其完全或部分覆盖的每个屏幕网格单元创建一个覆盖蒙版。每个像素存储所有相关片元的列表。不透明的片段可以剔除它们后面的片元，类似于z-buffer。所有片元都存储为透明表面。形成所有列表后，通过遍历片元并解析每个样本来产生最终结果。

通过DirectX 11[611,1765]中公开的新功能，在GPU上创建片元链接列表的想法成为可能。使用的功能包括无序访问视图(UAV)和原子操作，如[第3.8节][netlink3.8]所述。通过访问覆盖掩码和计算每个样本的像素着色器的能力启用了通过MSAA的抗锯齿。该算法通过光栅化每个透明表面并插入长数组中生成的片元来工作。除了颜色和深度之外，还会生成一个单独的指针结构，它将每个片元链接到为像素存储的前一个片元。然后执行单独的通道，其中渲染屏幕填充四边形，以便在每个像素处计算像素着色器。此着色器通过跟踪链接检索每个像素处的所有透明片元。检索到的每个片元与之前的片元依次排序。然后将这个排序列表从后到前混合，以给出最终的像素颜色。因为混合是由像素着色器执行的，如果需要，可以为每个像素指定不同的混合模式。GPU和API的持续发展通过降低使用原子运算符的成本提高了性能[914]。

A-buffer的优点是只分配每个像素所需的片元，GPU上的链表实现也是如此。这在某种意义上也可能是一个缺点，因为在渲染帧开始之前，所需的存储量是未知的。具有头发、烟雾或其他具有许多重叠透明表面的物体的场景会产生大量的碎片。Andersson[46]指出，对于复杂的游戏场景，多达50个透明物体（如树叶）网格和多达200个半透明粒子可能会重叠。

GPU通常具有预先分配的内存资源，例如缓冲区和数组，链表方法也不例外。用户需要决定多少内存是足够的，内存不足会导致明显的伪影。Salvi和Vaidyanathan[1532]提出了一种解决这个问题的方法，即多层alpha混合，使用Intel引入的称为像素同步的GPU功能。请参见图5.36。此功能提供可编程混合，其开销低于原子。他们的方法重新设计了存储和混合，以便在内存耗尽时优雅地降级。粗略的排序顺序可以使他们的方案受益。DirectX 11.3引入了光栅化顺序视图（[第3.8节][netlink3.8]），这是一种缓冲区，允许在任何支持此功能的GPU上实现这种透明度方法[327,328]。移动设备有一种称为切片本地存储的类似技术，允许它们实现多层alpha混合[153]。然而，这种机制有性能成本，因此这种类型的算法可能很昂贵[1931]。

<div align = "center">

![Figure5.36]

</div>

<div align = "center">

**图5.36**. 在左上角，执行了传统的从后到前的alpha混合，由于不正确的排序顺序而导致渲染错误。在右上角，A缓冲区用于提供完美的非交互式结果。左下方显示了使用多层Alpha混合的渲染。右下角显示了A缓冲区和多层Alpha混合图像之间的差异，为可见性乘以4[1532]。（图片由英特尔公司的Marco Salvi和Karthik Vaidyanathan提供。）

</div>

这种方法建立在Bavoil等人[115]引入的k缓冲区的思想之上。其中前几个可见层被尽可能地保存和排序，更深的层被丢弃并尽可能地合并。毛勒等人[1142]使用k-buffer并通过使用加权平均来解释这些更远的深层。加权和[1202]和加权平均[118]透明度技术是顺序无关的，是单通道的，并且几乎可以在每个GPU上运行。问题是它们没有考虑对象的顺序。因此，例如，使用alpha表示覆盖范围，薄纱蓝色围巾上的薄纱红围巾呈现紫罗兰色，而正确地看到红色围巾带有一点蓝色。虽然几乎不透明的物体给出的结果很差，但这类算法对于可视化很有用，并且适用于高度透明的表面和粒子。请参见图5.37。

<div align = "center">

![Figure5.37]

</div>

<div align = "center">

**图5.37**. 随着不透明度的增加，对象顺序变得更加重要。（Dunn[394]之后的图像。）

</div>

在加权和透明度中，公式为:
$$
\textbf{c}_0 = \sum^n_{i=1}(\alpha_i\textbf{c}_i) + \textbf{c}_d(1-\sum^n_{i = 1}\alpha_i) \tag{5.27}
$$

其中$n$是透明表面的数量，$\textbf{c}_i$和$\alpha_i$表示透明度值的集合，$\textbf{c}_d$是场景不透明部分的颜色。在渲染透明表面时，这两个总和会被累加并单独存储，并且在透明通道结束时，会在每个像素处计算方程。这种方法的问题是第一个总和会饱和，即生成大于(1.0,1.0,1.0)的颜色值，并且背景颜色可能具有负面影响，因为alpha的总和可能超过1.0。

通常首选加权平均方程，因为它避免了这些问题：
$$
\begin{aligned}
\textbf{c}_\textrm{sum} &= \sum^n_{i=1}(\alpha_i\textbf{c}_i),\  \alpha_\textrm{sum} = \sum^n_{i = 1}\alpha_i \\
\textbf{c}_\textrm{wavg} &= \frac{\textbf{c}_\textrm{sum}}{\alpha_\textrm{sum}},\ \alpha_\textrm{avg} = \frac{\alpha_\textrm{sum}}{n} \\
u &= (1-\alpha_\textrm{avg})^n\\
\textbf{c}_o &= (1-u)\textbf{c}_\textrm{wavg} + u\textbf{c}_d\\
\end{aligned}
\tag{5.28}
$$

第一行表示在透明度渲染期间生成的两个单独缓冲区中的结果。对$\textbf{c}_\textrm{sum}$有贡献的每个表面都被赋予了一个由其alpha加权的影响；几乎不透明的表面贡献了更多的颜色，而几乎透明的表面几乎没有影响。通过将$\textbf{c}_\textrm{sum}$除以$\alpha_\textrm{sum}$，我们得到加权平均透明度颜色。值$\alpha_\textrm{avg}$是所有alpha值的平均值。值$u$是对$n$个透明表面应用此平均alpha值$n$次后目标（不透明场景）的预估可见性。最后一行实际上是$\textbf{over}$运算符，其中$(1 - u)$表示源的alpha。

加权平均的一个限制是，对于相同的alpha，它会平等地混合所有颜色，而不管顺序如何。McGuire和Bavoil[1176,1180]引入了加权混合顺序无关透明度，以提供更令人信服的结果。在他们的公式中，到表面的距离也会影响权重，更近的表面会产生更大的影响。此外，不是对alpha进行平均，而是通过将项$(1 - \alpha_i)$相乘并从1中减去来计算$u$，从而给出一组曲面的真实alpha覆盖率。这种方法产生的结果在视觉上更令人信服，如图5.38所示。

<div align = "center">

![Figure5.38]

</div>

<div align = "center">

**图5.38**. 两个不同的摄像机位置查看相同的引擎模型，均使用加权混合顺序无关透明度进行渲染。按距离加权有助于澄清哪些表面更靠近观察者[1185]。（图片由摩根麦奎尔提供。）

</div>

一个缺点是，在大型环境中彼此靠近的对象可以具有几乎相等的距离权重，使得结果与加权平均值几乎没有差异。此外，随着相机与透明物体的距离发生变化，深度权重可能会在效果上发生变化，但这种变化是渐进的。

McGuire和Mara[1181, 1185]扩展了这种方法，使其包括一种似是而非的透射颜色效果。如前所述，本节讨论的所有透明度算法混合各种颜色而不是过滤它们，模仿像素覆盖。为了提供滤色器效果，像素着色器读取不透明场景，每个透明表面将它在该场景中覆盖的像素乘以其颜色，将结果保存到第三个缓冲区。这个缓冲区，其中不透明对象现在被透明对象着色，然后在解析透明缓冲区时用于代替不透明场景。这种方法之所以有效，是因为与覆盖导致的透明度不同，有色传输是与顺序无关的。

还有其他算法使用此处介绍的几种技术中的元素。例如，Wyman[1931]根据内存要求、插入和合并方法、是否使用alpha或几何覆盖以及如何处理丢弃的片元对以前的工作进行分类。他提出了两种通过寻找先前研究中的空白而发现的新方法。他的随机分层alpha混合方法使用k缓冲区、加权平均和随机透明度。他的另一个算法是Salvi和Vaidyanathan方法的变体，使用覆盖掩码而不是alpha。

鉴于透明内容的类型、渲染方法和GPU能力种类繁多，因此渲染透明对象没有完美的解决方案。我们将感兴趣的读者推荐给Wyman的论文[1931]和Maule等人对交互式透明度算法的更详细调查[1141]。McGuire的演讲[1182]给出了该领域更广阔的视野，贯穿了其他相关现象，例如体积照明、彩色透射和折射，这些将在本书后面更深入地讨论。

### 5.5.3 预乘Alpha和合成

$\textbf{over}$运算符还用于将照片或对象的合成渲染混合在一起。这个过程称为合成 [199, 1662]。在这种情况下，每个像素的alpha值与对象的RGB颜色值一起存储。由Alpha通道形成的图像有时称为遮罩。它显示了对象的轮廓形状。有关示例，请参见第203页上的[图6.27][netlink6.6]。然后可以使用此RGBα图像将其与其他此类元素或背景混合。

使用合成RGBα数据的一种方法是使用预乘alpha（也称为关联alpha）。也就是说，RGB值在使用前乘以alpha值。这使得合成$\textbf{over}$方程更有效：
$$
\textbf{c}_o = \textbf{c}^′_s + (1 − α_s)\textbf{c}_d \tag{5.29}
$$

其中$\textbf{c}^′_s$是预乘的源通道，取代了方程5.25中的$α_s\textbf{c}_s$。预乘alpha还可以在不改变混合状态的情况下使用$\textbf{over}$和加法混合，因为现在在混合期间添加了源颜色[394]。请注意，对于预乘RGBα值，RGB分量通常不大于alpha值，尽管它们可以创建一个特别明亮的半透明值。

渲染合成图像自然地与预乘alpha相吻合。在黑色背景上渲染的抗锯齿不透明对象默认提供预乘值。假设一个白色(1,1,1)三角形沿其边缘覆盖了某个像素的40%。使用（极其精确的）抗锯齿，像素值将设置为0.4的灰度，即我们将保存该像素的颜色(0.4,0.4,0.4)。如果存储了alpha值，也将是0.4，因为这是三角形覆盖的区域。RGBα值为(0.4,0.4,0.4,0.4)，这是一个预乘值。

存储图像的另一种方式是使用未乘的alpha，也称为未关联的alpha，甚至是令人费解的术语非预乘alpha。一个未相乘的alpha就是它所说的：RGB值不乘以alpha值。对于白色三角形示例，未相乘的颜色将为 (1,1,1,0.4)。这种表示具有存储三角形原始颜色的优点，但此颜色在显示之前始终需要乘以存储的alpha。每当执行过滤和混合时，最好使用预乘数据，因为线性插值等操作使用未乘的alpha[108, 164]无法正常工作。进一步讨论见[第6.6节][netlink6.6]末尾。预乘alpha还允许更清晰的理论处理[1662]。

对于图像处理应用程序，未关联的alpha可用于屏蔽照片，而不会影响底层图像的原始数据。此外，未关联的alpha意味着可以使用颜色通道的完整精度范围。也就是说，必须注意正确地将未相乘的RGBα值与用于计算机图形计算的线性空间进行转换。例如，没有浏览器可以正确执行此操作，它们也不太可能这样做，因为现在预期会出现不正确的行为[649]。支持alpha的图像文件格式包括PNG（仅未关联的alpha）、OpenEXR（仅关联）和TIFF（两种类型的alpha）。

与Alpha通道相关的一个概念是色度键控[199]。这是视频制作中的一个术语，其中演员在绿色或蓝色屏幕上拍摄并与背景混合。在电影工业中，这个过程被称为绿屏或蓝屏。这里的想法是指定特定的色调（用于电影作品）或精确值（用于计算机图形）被认为是透明的；每当检测到背景时都会显示背景。这允许仅使用RGB颜色为图像赋予轮廓形状；不需要存储 alpha。该方案的一个缺点是对象在任何像素处要么完全不透明，要么完全透明，即alpha实际上只有1.0或0.0。例如，GIF格式允许将一种颜色指定为透明。

[netlink3.8]:netlink3.8
[netlink6.6]:netlink6.6
[netlink14.5]:netlink14.5

[Figure5.31]:Figure/Figure5.31.JPG
[Figure5.32]:Figure/Figure5.32.JPG
[Figure5.33]:Figure/Figure5.33.JPG
[Figure5.34]:Figure/Figure5.34.JPG
[Figure5.35]:Figure/Figure5.35.JPG
[Figure5.36]:Figure/Figure5.36.JPG
[Figure5.37]:Figure/Figure5.37.JPG
[Figure5.38]:Figure/Figure5.38.JPG