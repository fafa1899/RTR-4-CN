## 4.7 投影

在实际渲染场景之前，场景中的所有相关对象都必须投影到某种平面或某种类型的简单容体中。之后，进行裁剪和渲染（[第2.3节][netlink2.3]）。

本章到目前为止看到的变换使第四个坐标$w$分量不受影响。也就是说，点和向量在变换后保留了它们的类型。此外，4×4矩阵的底行一直是$(0\,0\,0\,1)$。透视投影矩阵是这两个属性的例外：底行包含向量和点操作数，并且经常需要齐次化过程。即$w$通常不是1，因此需要除以$w$才能获得非齐次点。本节首先讨论的正交投影是一种更简单的投影，也是常用的投影。它不影响$w$分量。

在本节中，假设观看者沿相机的负z轴观看，y轴朝上，x轴朝右。这是一个右手坐标系。一些书籍和软件，例如DirectX，使用左手系统，其中观看者沿着相机的正z轴观看。两种系统同样有效，最终达到同样的效果。

### 4.7.1 正射投影

正投影的一个特点是平行线在投影后保持平行。当使用正交投影查看场景时，无论与相机的距离如何，对象都保持相同的大小。矩阵$\textbf{P}_o$，如下所示，是一个简单的正交投影矩阵，它使一个点的$x$和$y$分量保持不变，同时将z分量设置为零，即它正交投影到平面$z = 0$上：
$$
\textbf{P}_o = 
\left(
\begin{matrix}
   1 & 0 & 0 & 0\\
   0 & 1 & 0 & 0\\
   0 & 0 & 0 & 0\\
   0 & 0 & 0 & 1\\
\end{matrix}
\right)
\tag{4.62}
$$

该投影的效果如图4.17所示。显然，$\textbf{P}_o$是不可逆的，因为它的行列式$|\textbf{P}_o| = 0$。也就是说，转换从三个维度降到了两个维度，没有办法找回被降维的维度。使用这种正交投影进行查看的一个问题是，它可以投影正z值的点和负z值的点到投影平面上。将z值（以及x和y值）限制在某个区间内通常很有用，例如从$n$（近平面）到$f$（远平面）$^4$。 这是下一次转换的目的。

<div align = "center">

![Figure4.17]

</div>

<div align = "center">

**图4.17**. 公式4.62生成的简单正射投影的三个不同视图。当观察者沿负z轴观看时，可以看到该投影，这意味着投影简单地跳过（或设置为零）z坐标，同时保持x和y坐标。请注意，$z = 0$两侧的对象都投影到投影平面上。

</div>


执行正交投影的更常见矩阵由六元组$(l,r,b,t,n,f)$表示，表示左、右、底、顶、近和远平面。该矩阵将这些平面形成的轴对齐边界框（AABB；参见[第22.2节][netlink22.2]中的定义）缩放并转换为以原点为中心的轴对齐立方体。AABB的最小角为$(l,b,n)$，最大角为$(r,t,f)$。认识到$n > f$很重要，因为我们在这个空间容体上向下看负z轴。我们的常识是，near值应该比far值小，所以可以让用户这样提供它们，然后我们在内部对它们取反。

在OpenGL中，轴对齐立方体的最小角为$(-1,-1,-1)$，最大角为$(1,1,1)$； 在DirectX中，边界是$(-1,-1,0)$到 $(1,1,1)$。该立方体称为标准视图体，该体积中的坐标称为标准化设备坐标（NDC坐标）。转换过程如图4.18所示。转换为标准视图体的原因是，可以通过其更有效地执行裁剪操作。

<div align = "center">

![Figure4.18]

</div>

<div align = "center">

**图4.18**. 转换标准视图体上的轴对齐框。左边的框首先被平移，使其中心与原点重合。然后对其进行缩放以获得标准视图体的大小，如右图所示。

</div>

在转换为标准视图体后，要渲染的几何体的顶点将被裁剪到这个立方体上。立方体之内几何体，最终通过将还需处理的的单位正方形映射到屏幕来实现渲染。此正射变换如下所示：
$$
\begin{aligned}
\textbf{P}_o = \textbf{S}(\textbf{s})\textbf{T}(\textbf{t}) &= 
\left(
   \begin{matrix}
   \frac{2}{r-l} & 0 & 0 & 0\\
   0 & \frac{2}{t-b} & 0 & 0\\
   0 & 0 & \frac{2}{f-n} & 0\\
   0 & 0 & 0 & 1\\
   \end{matrix}
\right) 
\left(
   \begin{matrix}
   1 & 0 & 0 & -\frac{l+r}{2}\\
   0 & 1 & 0 & -\frac{t+b}{2}\\
   0 & 0 & 1 & -\frac{f+n}{2}\\
   0 & 0 & 0 & 1\\
   \end{matrix}
\right)\\
&= 
\left(
   \begin{matrix}
   \frac{2}{r-l} & 0 & 0 & -\frac{r+l}{r-l}\\
   0 & \frac{2}{t-b} & 0 & -\frac{t+b}{t-b}\\
   0 & 0 & \frac{2}{f-n} & -\frac{f+n}{f-n}\\
   0 & 0 & 0 & 1\\
   \end{matrix}
\right)
\end{aligned}
\tag{4.63}
$$

正如这个方程所建议的，$\textbf{P}_o$可以写成级联矩阵：先是平移，$\textbf{T}(\textbf{t})$，然后是一个缩放矩阵，$\textbf{S}(\textbf{s})$，其中$\textbf{s} = (2/(r − l),2/(t − b),2/(f − n))$和$\textbf{t} = (−(r + l)/2, −(t + b)/2, −(f + n)/2)$。这个矩阵是可逆的$^5$，即$\textbf{P}^{−1}_o = \textbf{T}(−\textbf{t})\textbf{S}((r − l)/2,(t − b)/2,(f − n)/2)$。

在计算机图形学中，投影后最常使用左手坐标系——即，对于视口，x轴向右，y轴向上，z轴进入视口。由于远值小于我们定义AABB的方式的近值，因此正交变换将始终包括镜像变换。要看到这一点，假设原始AABB与目标（标准视图体）大小相同。那么AABB的坐标是$(-1,-1,1)$对应于$(l,b,n)$，并且$(1,1,-1)$对应该于$(r,t,f)$。将其应用于方程4.63得到：
$$
\textbf{P}_o = 
\left(
   \begin{matrix}
   1 & 0 & 0 & 0\\
   0 & 1 & 0 & 0\\
   0 & 0 & -1 & 0\\
   0 & 0 & 0 & 1\\
   \end{matrix}
\right)
\tag{4.64}
$$

这正是一个镜像矩阵。这种镜像性会将右手观察坐标系（向下看负 z 轴）转换到左手标准化设备坐标。

DirectX将$z$深度映射到范围[0,1]而不是OpenGL的[−1,1]。这可以通过在正交矩阵之后应用一个简单的缩放和平移矩阵来实现，即:
$$
\textbf{M}_{st} = 
\left(
   \begin{matrix}
   1 & 0 & 0 & 0\\
   0 & 1 & 0 & 0\\
   0 & 0 & 0.5 & 0.5\\
   0 & 0 & 0 & 1\\
   \end{matrix}
\right)
\tag{4.65}
$$

因此，DirectX中使用的正交矩阵是：
$$
\textbf{M}_{st} = 
\left(
   \begin{matrix}
   \frac{2}{r-l} & 0 & 0 & -\frac{r+l}{r-l}\\
   0 & \frac{2}{t-b} & 0 & -\frac{t+b}{t-b}\\
   0 & 0 & \frac{1}{f-n} & -\frac{n}{f-n}\\
   0 & 0 & 0 & 1\\
   \end{matrix}
\right)
\tag{4.66}
$$

上式通常以转置形式呈现，因为DirectX使用行主序形式来编写矩阵。

### 4.7.2 透视投影

比正交投影更复杂的变换是透视投影，它通常用于大多数计算机图形应用程序。平行线在透视投影后一般不平行；相反，它们可能会在极端情况下收敛成一个点。其视角更接近于我们对世界的感知，即距离越远的物体越小。

首先，我们将展示投影到平面$z = -d, d > 0$的透视投影矩阵的启发性推导。我们从世界空间推导，以简化世界到视图如何转换的理解。这个推导之后是更传统的矩阵，例如，OpenGL[885]。


假设相机（视点）位于原点，并且我们想要将一个点$\textbf{p}$投影到平面$z = −d, d > 0$上，产生一个新点$\textbf{q} = (q_x, q_y, −d)$。图4.19描述了这种情况。从该图中所示的相似三角形，可得到$\textbf{q}$的$x$分量的以下推导：
$$
\frac{q_x}{p_x} = \frac{-d}{p_z} \quad \Longleftrightarrow \quad q_x = -d \frac{p_x}{p_z}
$$

<div align = "center">

![Figure4.19]

</div>

<div align = "center">

**图4.19**. 用于导出透视投影矩阵的符号。点$\textbf{p}$被投影到平面$z = -d, d > 0$，这产生了投影点$\textbf{q}$。投影是从相机位置的角度进行的，在这种情况下是原点。推导中使用的用于x分量的相似三角形显示在图右侧。

</div>

$\textbf{q}$的其他分量的表达式是$q_y = -dp_y/p_z$（类似地从$q_x$的计算）和$q_z=-d$。连同上述公式，这些为我们提供了透视投影矩阵$\textbf{P}_p$，如下所示：
$$
\textbf{P}_p = 
\left (
\begin{matrix}
   1 & 0 & 0 & 0\\
   0 & 1 & 0 & 0\\
   0 & 0 & 1 & 0\\
   0 & 0 & -1/d & 0\\
\end{matrix}
\right)
\tag{4.68}
$$

该矩阵产生正确的透视投影由下式确定:
$$
\textbf{q} = \textbf{P}_p\textbf{p} = 
\left (
\begin{matrix}
   1 & 0 & 0 & 0\\
   0 & 1 & 0 & 0\\
   0 & 0 & 1 & 0\\
   0 & 0 & -1/d & 0\\
\end{matrix}
\right)
\left (
\begin{matrix}
p_x \\
p_y \\
p_z \\
1
\end{matrix}
\right) = 
\left (
\begin{matrix}
p_x \\
p_y \\
p_z \\
-p_z / d
\end{matrix}
\right) 
\Rightarrow
\left (
\begin{matrix}
-dp_x/p_z \\
-dp_y/p_z \\
-d \\
1
\end{matrix}
\right) 
\tag{4.69}
$$

最后一步来自这样一个事实，即整个向量除以$w$分量（在本例中为$-p_z/d$），在最后一个位置得到1。由于我们正在投影到这个平面上，因此产生的$z$值总是$-d$。

直观地，很容易理解为什么齐次坐标允许投影。齐次过程的一种几何解释是它将点$(p_x, p_y, p_z )$投影到平面$w = 1$上。

与正交变换一样，还有一个透视变换，它不是实际投影到平面上（这是不可逆的），而是将视锥体转换为前面描述的标准视图体。这里假设视锥体从$z = n$开始，在$z = f$结束，$0>n>f$。$z=n$处的矩形在$(l,b,n)$处具有最小角点，在$(r,t,n)$处具有最大角点。如图4.20所示。

<div align = "center">

![Figure4.20]

</div>

<div align = "center">

**图4.20**. 矩阵$\textbf{P}_p$将视锥体转换为单位立方体，称为标准视图体。

</div>

参数$(l,r,b,t,n,f)$决定了相机的视锥。水平视场由平截头体的左右平面（由$l$和$r$确定）之间的角度决定。以同样的方式，垂直视场由顶部平面和底部平面之间的角度决定（由$t$和$b$决定）。视野越大，相机“看到”的就越多。不对称截头锥体可以由$r \neq -l$或$t \neq -b$创建。例如，非对称截头体用于立体观看和虚拟现实（[第21.2.3 节][netlink21.2]）。

视野/视野是提供场景感的重要因素。与计算机屏幕相比，眼睛本身具有物理视野。这个关系如下：
$$
\phi = 2\textrm{arctan}(w/(2d)) \tag{4.70}
$$

其中$\phi$是视场，$w$是物体垂直于视线的宽度，$d$是到物体的距离。例如，一个25英寸的显示器大约有22英寸宽。在12英寸外，水平视野为85度；在20英寸处，它是58度；在30英寸，40度。同样的公式可用于从相机镜头尺寸转换为视场，例如，35mm相机的标准50mm镜头（具有36mm宽框架尺寸）给出$\phi = 2\textrm{arctan}(36/(2 · 50)) = 39.6$度。

与物理设置相比，使用更窄的视野会减少透视效果，因为观察者会放大场景。设置更宽的视野会使物体看起来失真（如使用广角相机镜头），尤其是在屏幕边缘附近，并且会夸大附近物体的比例。然而，更宽的视野让观看者感觉物体更大、更令人印象深刻，并且具有为用户提供有关周围环境的更多信息的优势。

将截头体变换为单位立方体的透视变换矩阵由公式4.71给出：
$$
\textbf{P}_p = 
\left (
\begin{matrix}
   \frac{2n}{r-l} & 0 & -\frac{r+l}{r-l} & 0\\
   0 & \frac{2n}{t-b} & -\frac{t+b}{t-b} & 0\\
   0 & 0 & \frac{f+n}{f-n} & -\frac{2fn}{f-n}\\
   0 & 0 & 1 & 0\\
\end{matrix}
\right)
\tag{4.71}
$$

将此变换应用于一个点后，我们将得到另一个点$\textbf{q} = (q_x, q_y, q_z, q_w)^T$。该点的$w$分量$q_w$将（大多数情况下）非零且不等于1。要得到投影点$\textbf{p}$，我们需要除以$q_w$，即:
$$
\textbf{p} = (q_x /q_w, q_y/q_w, q_z/q_w, 1) \tag{4.72}
$$

矩阵$\textbf{P}_p$总是确保$z = f$映射到$+1$，$z = n$映射到$-1$。

超出远平面的对象将被剪裁，因此不会出现在场景中。透视投影可以处理取到无穷远的远平面，这使得方程4.71变为：
$$
\textbf{P}_p = 
\left (
\begin{matrix}
   \frac{2n}{r-l} & 0 & -\frac{r+l}{r-l} & 0\\
   0 & \frac{2n}{t-b} & -\frac{t+b}{t-b} & 0\\
   0 & 0 & 1 & -2n\\
   0 & 0 & 1 & 0\\
\end{matrix}
\right)
\tag{4.73}
$$

总而言之，应用透视变换（以任何形式）$\textbf{P}_p$，然后进行裁剪和齐次化（除以 w），从而得到归一化的设备坐标。

要获得OpenGL中使用的透视变换，首先乘以$\textbf{S}(1,1,−1,1)$，原因与正交变换相同。这简单地取反了公式4.71第三列中的值。应用此镜像变换后，near和far值作为正值输入，$0 < n' < f'$，正如它们传统上呈现给用户的。 但是，它们仍然表示沿世界负z轴的距离，即观察方向。这里是OpenGL的方程，仅供参考：
$$
\textbf{P}_\textrm{OpenGL} = 
\left (
\begin{matrix}
   \frac{2n'}{r-l} & 0 & \frac{r+l}{r-l} & 0\\
   0 & \frac{2n'}{t-b} & \frac{t+b}{t-b} & 0\\
   0 & 0 & -\frac{f'+n'}{f'-n'} & -\frac{2f'n'}{f'-n'}\\
   0 & 0 & -1 & 0\\
\end{matrix}
\right)
\tag{4.74}
$$

更简单的设置是仅提供垂直视野$\phi$，高宽比$a = w/h$（其中$w × h$是屏幕分辨率）,$n'$和$f'$。此时结果为：
$$
\textbf{P}_\textrm{OpenGL} = 
\left (
\begin{matrix}
   c/a & 0 & 0 & 0\\
   0 & c & 0 & 0\\
   0 & 0 & -\frac{f'+n'}{f'-n'} & -\frac{2f'n'}{f'-n'}\\
   0 & 0 & -1 & 0\\
\end{matrix}
\right)
\tag{4.75}
$$

其中$c = 1.0/\textrm{tan}(\phi/2)$. 这个矩阵与旧的gluPerspective()所做的完全一样，它是OpenGL实用程序库(GLU)的一部分。

一些API（例如 DirectX）将近平面映射到$z = 0$（而不是$z = -1$），将远平面映射到$z = 1$。此外，DirectX 使用左手坐标系来定义其投影矩阵。这意味着DirectX沿z轴正方向观察，并将近和远值显示为正数。这是 DirectX 方程：
$$
\textbf{P}_{p[0,1]} = 
\left (
\begin{matrix}
   \frac{2n'}{r-l} & 0 & -\frac{r+l}{r-l} & 0\\
   0 & \frac{2n'}{t-b} & -\frac{t+b}{t-b} & 0\\
   0 & 0 & \frac{f'}{f'-n'} & -\frac{f'n'}{f'-n'}\\
   0 & 0 & 1 & 0\\
\end{matrix}
\right)
\tag{4.76}
$$

DirectX在其文档中使用行主序形式，因此该矩阵通常以转置形式呈现。

使用透视变换的一个效果是计算的深度值不随输入$p_z$值线性变化。使用等式4.74-4.76中的任何一个乘以点$\textbf{p}$，我们可以看到:
$$
\textbf{v} = \textbf{P}\textbf{p} = 
\left (
\begin{matrix}
   ...\\
   ...\\
   dp_z+e\\
   \pm{p_z}\\
\end{matrix}
\right)
\tag{4.77}
$$

其中$v_x$和$v_y$的细节已被省略，常数$d$和$f$取决于所选矩阵。例如，如果我们使用公式 4.74，则$d = −(f' +n')/(f'−n')$，$e = −2f'n'/(f'−n')$，并且$v_x = −p_z$。为了获得归一化设备坐标 (NDC) 中的深度，我们需要除以$w$分量，其结果为：
$$
z_\textrm{NDC} = \frac{dp_z+e}{-p_z} = d - \frac{e}{p_z} \tag{4.78}
$$

其中$z_\textrm{NDC}∈[−1,+1]$用于OpenGL投影。可以看出，输出深度$z_\textrm{NDC}$与输入深度$p_z$成反比。


例如，如果$n'=10$且$f'=110$（使用OpenGL术语），当$p_z$为负z轴（即中点）下方60个单位时，归一化设备坐标深度值为0.833，而不是0。图4.21显示了改变近平面到原点的距离的影响。近平面和远平面的放置会影响z缓冲区的精度。这种影响在[第23.7节][netlink23.7]中进一步讨论。

<div align = "center">

![Figure4.21]

</div>

<div align = "center">

**图4.21**. 改变近平面与原点的距离的影响。距离$f'-n'$保持恒定为100。随着近平面变得更接近原点，更靠近远平面的点使用更小的归一化设备坐标 (NDC) 深度空间范围。这会导致$z$缓冲区在更远的距离上不太准确。

</div>

有几种方法可以提高深度精度。一种常用的方法，我们称之为反向z，是使用浮点深度或整数存储1.0−$z_\textrm{NDC}$[978]。其比较如图4.22所示。Reed[1472]通过模拟显示，使用具有反向z的浮点缓冲区能提供最佳精度，这也是整数深度缓冲区（通常每个深度24位）的首选方法。对于标准映射（即非反转z），如Upchurch和Desbrun[1803]所建议的那样，在变换中分离投影矩阵会降低误差率。例如，使用$\textbf{P}(\textbf{Mp})$比使用$\textbf{Tp}$更好，其中$\textbf{T} = \textbf{PM}$。此外，在[0.5,1.0]范围内，fp32和int24在精度上非常相似，因为fp32具有23位尾数。使$z_\textrm{NDC}$与$1/p_z$成比例的原因是它使硬件更简单，深度压缩更成功，这在[第23.7节][netlink23.7]中有更多讨论。

<div align = "center">

![Figure4.22]

</div>

<div align = "center">

**图4.22**. 使用DirectX变换设置深度缓冲区的不同方法，即$z_\textbf{NDC} ∈ [0,+1]$。左上角：标准整数深度缓冲区，此处以4位精度显示（因此y轴上有16个标记）。右上角：远平面设置为$\infty$，两个轴上的小偏移表明这样做不会损失太多精度。左下角：浮点深度有3个指数位和3个尾数位。请注意y轴上的分布是如何非线性的，这使得x轴上的情况更糟。右下：反向浮点深度，即$1−z_\textbf{NDC}$ ，结果分布更好。（插图由内森·里德提供。）

</div>

Lloyd[1063]建议使用深度值的对数来提高阴影贴图的精度。Lauritzen等人[991]使用前一帧的z缓冲区来确定最大近平面和最小远平面。对于屏幕空间深度，Kemen[881]建议对每个顶点使用以下重新映射：
$$
\begin{aligned}
z &= w(\textrm{log}_2(\textrm{max}(10^{−6}, 1+w))f_c−1) \quad [\textrm{OpenGL}]\\
z &= w\textrm{log}_2(\textrm{max}(10^{−6}, 1+w))f_c / 2 \quad [\textrm{DirectX}]\\
\end{aligned}
\tag{4.79}
$$

其中$w$是投影矩阵后顶点的$w$值，z是顶点着色器的输出z。常数$f_c$是$f_c = 2/\textrm{log}_2 (f + 1)$，其中$f$是远平面。当此变换仅在顶点着色器中应用时，GPU仍将在三角形上线性插入深度，尽管顶点的深度是非线性变换深度（公式 4.79）。由于对数是单调函数，只要分段线性插值和精确的非线性变换深度值之间的差异很小，遮挡剔除硬件和深度压缩技术仍然有效。对于具有足够几何细分的大多数情况来说，情况确实如此。但是，也可以对每个片元应用变换。这是通过输出$e = 1+w$的每个顶点值来完成的，然后由GPU对三角形进行插值。然后像素着色器将片段深度修改为 $\textrm{log}_2(e_i)f_c/2$，其中$e_i$是$e$的内插值。当GPU中没有浮点深度以及使用大深度距离进行渲染时，此方法是一个不错的选择。

Cozzi[1605]提出使用多个截头锥体，这可以有效地提高精度以达到任何所需的比率。视锥体在深度方向上被分成几个不重叠的较小的子视锥体，它们的联合正是视锥体。子视锥体按从后到前的顺序呈现。首先，颜色和深度缓冲区都被清除，所有要渲染的对象都被分类到它们重叠的每个子视锥体中。对于每个子视锥体，设置其投影矩阵，清除深度缓冲区，然后渲染与子视锥体重叠的对象。

***
$^4$ 近平面也称为前平面或hither；远平面也是背平面或yon。
$^5$ 当且仅当$n \neq f$，$l \neq r$，并且 $t \neq b$；否则，逆不存在。


[Figure4.17]:Figure/Figure4.17.JPG
[Figure4.18]:Figure/Figure4.18.JPG
[Figure4.19]:Figure/Figure4.19.JPG
[Figure4.20]:Figure/Figure4.20.JPG
[Figure4.21]:Figure/Figure4.21.JPG
[Figure4.22]:Figure/Figure4.22.JPG

[netlink2.3]:netlink2.3
[netlink21.2]:netlink21.2
[netlink22.2]:netlink22.2
[netlink23.7]:netlink23.7

