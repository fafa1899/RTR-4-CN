## 5.4 锯齿和抗锯齿

想象一个大的黑色三角形在白色背景上缓慢移动。当一个屏幕网格单元被三角形覆盖时，代表这个单元的像素值应该在强度上平滑下降。在各种基本渲染器中通常发生的情况是，网格单元的中心被覆盖的那一刻，像素颜色立即从白色变为黑色。标准GPU渲染也不例外。请参见图5.14的最左侧列。

<div align = "center">

![Figure5.14]

</div>

<div align = "center">

**图5.14**. 上面一行显示了三个图像，其中三角形、直线和一些点具有不同级别的抗锯齿。下排图像是上排的放大图。最左边的列每个像素只使用一个样本，这意味着没有使用抗锯齿。中间列的图像每个像素使用四个样本（以网格模式）渲染，右列每个像素使用八个样本（在4×4棋盘格中，对一半的正方形进行采样）。

</div>

三角形以像素为单位显示为存在或不存在。绘制的线条也有类似的问题。因此，边缘看起来呈锯齿状，因此这种视觉伪影被称为“锯齿”，在动画时会变成“爬行动物”。更正式地说，这个问题被称为锯齿，避免它的努力被称为抗锯齿技术。

采样理论和数字滤波的主题足够大，足以填满自己的书[559,1447,1729]。由于这是渲染的关键领域，因此将介绍采样和滤波的基本理论。然后，我们将专注于当前可以实时完成的工作以减轻锯齿伪影。

### 5.4.1 采样和滤波理论

渲染图像的过程本质上是一个采样任务。之所以如此，是因为图像的生成是对三维场景进行采样以获得图像中每个像素（离散像素阵列）的颜色值的过程。要使用纹理映射（[第6章][netlink6.0]），必须重新采样纹素才能在不同条件下获得良好的结果。为了在动画中生成一系列图像，通常以统一的时间间隔对动画进行采样。本节介绍了采样、重建和过滤的主题。为简单起见，大多数材料将在一维中呈现。这些概念也自然扩展到二维，因此可以在处理二维图像时使用。

图5.15显示了如何以均匀间隔对连续信号进行采样，即离散化。此采样过程的目标是以数字方式表示信息。这样做可以减少信息量。然而，需要对采样信号进行重建以恢复原始信号。这是通过对采样信号进行滤波来完成的。

<div align = "center">

![Figure5.15]

</div>

<div align = "center">

**图5.15**. 对连续信号（左）进行采样（中），然后通过重建恢复原始信号（右）。

</div>

无论何时进行采样，都可能发生混叠。这是一个不需要的人工制品，我们需要与混叠作斗争以生成令人愉悦的图像。混叠的一个典型例子是在老西部片中看到的电影摄影机拍摄的旋转马车车轮。由于辐条的移动速度比相机记录图像的速度要快得多，因此车轮可能看起来在缓慢旋转（向后或向前），甚至看起来根本没有旋转。这可以在图5.16中看到。之所以会出现这种效果，是因为车轮的图像是在一系列时间步长中拍摄的，称为时间混叠。

<div align = "center">

![Figure5.16]

</div>

<div align = "center">

**图5.16**. 顶行显示了一个旋转的轮子（原始信号）。这在第二行中采样不足，使其看起来向相反方向移动。这是由于采样率过低而导致混叠的示例。在第三行，采样率恰好是每转两个样本，我们无法确定轮子在哪个方向旋转。这是Nyquist极限。在第四行，采样率高于每转两个样本，我们突然可以看到轮子向正确的方向旋转。

</div>

计算机图形学中锯齿的常见例子是光栅化线或三角形边缘的“锯齿”，被称为“萤火虫”的闪烁高光，以及带有棋盘格图案的纹理被缩小时（[第6.2.2节][netlink6.2]）。

当以太低的频率对信号进行采样时，就会发生混叠。然后，采样信号看起来是比原始信号频率低的信号。如图5.17所示。对于要正确采样的信号（即，可以从样本中重建原始信号），采样频率必须大于要采样的信号的最大频率的两倍。这通常被称为采样定理，采样频率被称为奈奎斯特速率 [1447] 或奈奎斯特极限，以瑞典科学家Harry Nyquist(1889-1976) 命名，他在1928年发现了这一点。奈奎斯特极限也如图5.16所示。该定理使用术语“最大频率”这一事实意味着信号必须是带限的，这只是意味着没有任何频率超过一定的限制。换句话说，信号必须相对于相邻样本之间的间距足够平滑。

<div align = "center">

![Figure5.17]

</div>

<div align = "center">

**图5.17**. 蓝色实线是原始信号，红色圆圈表示均匀间隔的采样点，绿色虚线是重建信号。上图显示采样率过低。因此，重建的信号似乎具有较低的频率，即原始信号的混叠。底部显示了恰好是原始信号频率两倍的采样率，重建的信号在这里是一条水平线。可以证明，如果采样率稍微增加一点，完美的重建是可能的。

</div>

使用点样本进行渲染时，3D场景通常不会受到带宽限制。三角形的边缘、阴影边界和其他现象会产生不连续变化的信号，因此会产生无限的频率[252]。此外，无论样本有多紧密，对象仍然可以足够小以至于根本无法对其进行采样。因此，在使用点采样渲染场景时，不可能完全避免锯齿问题，我们几乎总是使用点采样。但是，有时可以知道信号何时是带限的。一个例子是纹理应用于表面时。与像素的采样率相比，可以计算纹理样本的频率。如果此频率低于Nyquist限制，则无需特殊操作即可正确采样纹理。如果频率太高，则使用各种算法对纹理进行频带限制（[第6.2.2节][netlink6.2]）。

#### 重建

给定一个带限采样信号，我们现在将讨论如何从采样信号中重建原始信号。为此，必须使用过滤器。三种常用的过滤器如图5.18所示。请注意，滤波器的面积应始终为1，否则重建的信号可能会出现增长或缩小。

<div align = "center">

![Figure5.18]

</div>

<div align = "center">

**图5.18**. 左上方显示box过滤器，右上方显示tent过滤器。底部显示了sinc滤波器（其固定在x轴上）。

</div>

在图5.19中，box滤波器（最近邻）用于重建采样信号。这是使用最差的滤波器，因为生成的信号是不连续的阶梯状。 尽管如此，由于其简单性，它经常用于计算机图形学。从图中可以看出，box过滤器被放置在每个采样点上，然后进行缩放，使过滤器的最高点与采样点重合。所有这些缩放和转换的box函数的总和就是右侧显示的重建信号。

<div align = "center">

![Figure5.19]

</div>

<div align = "center">

**图5.19**. 使用box滤波器重建采样信号（左）。这是通过将box过滤器放置在每个采样点上，并在y方向上对其进行缩放，以使过滤器的高度与采样点相同。其总和是重建信号（右）。

</div>

box过滤器可以更换为任何其他过滤器。在图5.20中，tent滤波器也称为三角形滤波器，用于重建采样信号。请注意，该滤波器实现了相邻样本点之间的线性插值，因此它比box滤波器更好，因为重建的信号现在是连续的。

<div align = "center">

![Figure5.20]

</div>

<div align = "center">

**图5.20**. 使用tent滤波器重建采样信号（左）。重建的信号如右图所示。

</div>

然而，使用tent滤波器的信号的平滑度较差；采样点处存在陡峭的斜率变化。这与tent过滤器不是完美的重建过滤器这一事实有关。为了获得完美的重建，必须使用理想的低通滤波器。信号的频率分量是正弦波：$\textrm{sin}(2πf)$，其中$f$是该分量的频率。鉴于此，低通滤波器会去除所有频率高于滤波器定义的特定频率的频率分量。直观地说，低通滤波器去除了信号的尖锐特征，即滤波器模糊了它。理想的低通滤波器是sinc滤波器（图5.18底部）：
$$
\textrm{sinc}(x) = \frac{\textrm{sin}({\pi}x)}{{\pi}x}      \tag{5.22}
$$

傅里叶分析理论[1447]解释了为什么sinc滤波器是理想的低通滤波器。简而言之，推理如下。理想的低通滤波器是频域中的box滤波器，当它与信号相乘时，它会去除滤波器宽度以上的所有频率。将box滤波器从频域变换到空间域给出了一个sinc函数。同时，将乘法运算转化为卷积函数，这也是我们在本节中一直使用的，但没有实际描述该术语。

使用sinc滤波器重建信号可以得到更平滑的结果，如图5.21所示。采样过程会在信号中引入高频成分（突变），低通滤波器的任务就是去除这些成分。事实上，sinc滤波器消除了所有频率高于采样率1/2的正弦波。如公式5.22所示，sinc 函数是采样频率为1.0（即采样信号的最大频率必须小于 1/2）时的完美重建滤波器。更一般地，假设采样频率为$f_s$ ，即相邻样本之间的间隔为$1/f_s$。对于这种情况，完美的重建滤波器是$\textrm{sinc}(f_sx)$，它会消除所有高于$f_s/2$的频率。这在重新采样信号时很有用（下一节）。但是，sinc的滤波器宽度是无限的，并且在某些区域为负数，因此在实践中很少有用。

<div align = "center">

![Figure5.21]

</div>

<div align = "center">

**图5.21**. 在这里，sinc滤波器用于重建信号。sinc滤波器是理想的低通滤波器。

</div>

一方面，在低质量的box和tent过滤器之间有一个有用的中间地带，另一方面是不切实际的sinc过滤器。最广泛使用的过滤器函数[1214, 1289, 1413, 1793]介于这些极端之间。所有这些滤波器函数都与sinc函数有一些近似，但对它们影响的像素数量有限制。最接近sinc函数的滤波器在其部分域上具有负值。对于不希望或不切实际的负滤波器值的应用，通常使用没有负波瓣的滤波器（通常称为高斯滤波器，因为它们要么源自高斯曲线，要么类似于高斯曲线）[1402]。[第12.1][netlink12.1]节更详细地讨论了过滤器函数及其使用。

使用任何滤波器后，都会得到一个连续的信号。然而，在计算机图形学中，我们不能直接显示连续信号，但我们可以使用它们将连续信号重新采样到另一个大小，即放大或缩小信号。接下来讨论这个话题。

#### 重采样

重采样用于放大或缩小采样信号。假设原始样本点位于整数坐标（0,1,2,...），即样本之间有单位间隔。此外，假设在重采样后，我们希望新的样本点以样本之间的间隔$a$均匀定位。对于$a>1$，进行缩小（下采样），对于$a<1$，进行放大（上采样）。

放大是两者中较简单的情况，所以让我们从它开始。假设如上一节所示重建采样信号。直观地说，由于信号现在被完美地重建并且是连续的，所需要的只是以期望的间隔对重建的信号进行重新采样。这个过程可以在图5.22中看到。

<div align = "center">

![Figure5.22]

</div>

<div align = "center">

**图5.22**. 在右边，重建的信号已经以两倍的采样率重新采样，即发生了放大。

</div>

但是，当发生缩小时，此技术不起作用。原始信号的频率对于采样率来说太高以避免混叠。相反，已经表明应该使用$\textrm{sinc}(x/a)$的滤波器从采样的信号中创建连续信号[1447,1661]。之后，可以按所需的时间间隔重新采样。这可以在图5.23中看到。换句话说，通过在这里使用$\textrm{sinc}(x/a)$作为滤波器，增加了低通滤波器的宽度，从而去除了更多信号的高频成分。如图所示，（单个sinc的）滤波器宽度加倍，以将重采样率降低到原始采样率的一半。将其与数字图像相关联，这类似于首先对其进行模糊处理（以去除高频），然后以较低的分辨率重新采样图像。

<div align = "center">

![Figure5.23]

</div>

<div align = "center">

**图5.23**. 左边是采样信号和重建信号。在右侧，过滤器宽度加倍以使样本之间的间隔加倍，即进行了缩小。

</div>

以采样和过滤理论作为框架，现在讨论实时渲染中用于减少混叠的各种算法。

### 5.4.2 基于屏幕的抗锯齿

如果没有很好地采样和过滤，三角形的边缘会产生明显的伪影。阴影边界、镜面高光和其他颜色快速变化的现象可能会导致类似的问题。本节讨论的算法有助于提高这些情况的渲染质量。它们的共同点是它们是基于屏幕的，即它们只对管线的输出样本进行操作。没有一种最好的抗锯齿技术，因为每种技术在质量、捕捉清晰细节或其他现象的能力、运动过程中的外观、内存成本、GPU要求和速度方面都有不同的优势。

在图5.14中的黑色三角形示例中，一个问题是采样率低。在每个像素的网格单元的中心采集一个样本，因此对单元的了解最多的是中心是否被三角形覆盖。通过在每个屏幕网格单元中使用更多样本并以某种方式混合这些样本，可以计算出更好的像素颜色。如图5.24所示。

<div align = "center">

![Figure5.24]

</div>

<div align = "center">

**图5.24**. 在左侧，一个红色三角形被渲染，一个样本位于像素的中心。由于三角形没有覆盖样本，因此像素将是白色的，即使像素的大部分被红色三角形覆盖。在右侧，每个像素使用四个样本，可以看出，其中两个被红色三角形覆盖，从而产生粉红色的像素颜色。

</div>

基于屏幕的抗锯齿方案的一般策略是使用屏幕的采样模式，然后对样本进行加权和求和以产生像素颜色$\textbf{p}$:
$$
\textbf{p}(x,y) = \sum_{i=1}^{n}w_i\textbf{c}(i,x,y)  \tag{5.23}
$$

其中$n$是为像素获取的样本数。函数$\textbf{c}(i,x,y)$是一个样本颜色，而$w_i$是一个权重，在[0,1]范围内，样本将有助于整个像素的颜色。样本位置是根据它在系列1,...,n的某个样本来获取的，并且该函数还可以选择使用像素位置(x,y)的整数部分。换句话说，每个样本在屏幕网格上的采样位置是不同的，并且可选地，采样模式可以随像素而变化。样本通常是实时渲染系统（以及大多数其他渲染系统）中的点样本。因此，函数$\textbf{c}$可以被认为是两个函数。首先，函数$\textbf{f}(i,n)$检索屏幕上需要样本的浮点$(x_f,y_f)$位置。然后对屏幕上的这个位置进行采样，即检索该精确点的颜色。选择采样方案并配置渲染管道以计算特定子像素位置的样本，通常基于每帧（或每应用程序）设置。

抗锯齿中的另一个变量是$w_i$，即每个样本的权重。这些权重总和为1。实时渲染系统中使用的大多数方法都为其样本赋予了统一的权重，即$w_i = \frac{1}{n}$。图形硬件的默认模式，像素中心的单个样本，是上述抗锯齿方程的最简单情况。只有一项，该项的权重为1，采样函数$f$总是返回被采样像素的中心。

每个像素计算多个完整样本的抗锯齿算法称为超级采样（或过采样）方法。概念上最简单的全场景抗锯齿(FSAA)，也称为“超级采样抗锯齿”(SSAA)，以更高分辨率渲染场景，然后过滤相邻样本以创建图像。例如，假设1280×1024像素的图像是需要的。如果你在屏幕外渲染2560×2048的图像，然后在屏幕上平均每个2×2像素区域，则会生成所需的图像，每个像素有四个样本，并使用box过滤器进行过滤。请注意，这对应于图5.25中的2×2网格采样。这种方法成本高，因为所有子样本必须完全着色和填充，每个样本都有一个z缓冲区深度。FSAA的主要优势是简单。此方法的其他低质量版本仅在一个屏幕轴上以两倍的速率进行采样，因此称为1×2或2×1超级采样。通常，为简单起见，使用二次方分辨率和box滤波器。 NVIDIA的动态超分辨率功能是一种更精细的超级采样形式，其中场景以更高的分辨率渲染，并使用13个样本的高斯滤波器来生成显示的图像[1848]。

<div align = "center">

![Figure5.25]

</div>

<div align = "center">

**图5.25**. 一些像素采样方案的比较，范围从每个像素的最少样本到最多样本。Quincunx共享角点样本并将其中心样本加权为像素最终颜色的一半。2×2旋转网格比直线2×2网格捕获几乎水平边缘的更多灰度级。类似地，尽管使用的样本较少，但8-rooks模式比4×4网格捕获更多的灰度级。

</div>

一种与超级采样相关的采样方法是基于累积缓冲区的思想[637,1115]。这种方法不是使用一个大的屏幕外缓冲区，而是使用一个与所需图像具有相同分辨率的缓冲区，但每个通道的颜色位更多。为了获得一个场景的2×2采样，生成了四个图像，视图根据需要在屏幕x或y方向移动了半个像素。生成的每个图像都基于网格单元内的不同样本位置。每帧必须重新渲染场景几次并将结果复制到屏幕的额外成本使得该算法对于实时渲染系统来说成本很高。当性能不重要时，它对于生成更高质量的图像很有用，因为每个像素都可以使用任意数量的样本，放置在任何地方[1679]。累积缓冲区曾经是一个单独的硬件。它在OpenGL API中得到直接支持，但在3.0版中已弃用。在现代GPU上，可以在像素着色器中通过对输出缓冲区使用更高精度的颜色格式来实现累积缓冲区概念。

当对象边缘、镜面高光和锐利阴影等现象导致颜色突然变化时，需要额外的样本。通常可以使阴影更柔和，使高光更平滑以避免锯齿。特定对象类型的尺寸可以增加，例如电线，以保证它们沿其长度的每个位置覆盖至少一个像素[1384]。对象边缘的锯齿仍然是一个主要的采样问题。可以使用分析方法，在渲染过程中检测对象边缘并将其影响考虑在内，但这些方法通常比简单地获取更多样本更昂贵且鲁棒性较差。然而，诸如保守光栅化和光栅化顺序视图等GPU特性开辟了新的可能性 [327]。

超级采样和累积缓冲等技术通过生成完全指定的具有单独计算的着色和深度的样本来工作。整体增益相对较低且成本较高，因为每个样本都必须通过像素着色器。

多重采样抗锯齿(MSAA)通过为每个像素计算一次表面的着色并在样本之间共享此结果来降低高计算成本。例如，每个片段的像素可能有四个(x,y)样本位置，每个位置都有自己的颜色和z-depth，但像素着色器仅对应用于像素的每个对象片元进行一次评估。如果所有MSAA位置样本都被片段覆盖，则在像素中心评估着色样本。如果片段覆盖较少的位置样本，则可以移动着色样本的位置以更好地表示覆盖的位置。例如，这样做可以避免纹理边缘的阴影采样。这种位置调整称为质心采样或质心插值，如果启用，则由GPU自动完成。质心采样避免了非三角形问题，但可能导致导数计算返回不正确的值 [530,1041]。请参见图5.26。

<div align = "center">

![Figure5.26]

</div>

<div align = "center">

**图5.26**. 在中间，一个像素与两个对象重叠。红色物体覆盖了三个样本，蓝色只有一个。像素着色器评估位置以绿色显示。由于红色三角形覆盖了像素的中心，因此该位置用于着色器评估。蓝色对象的像素着色器在样本位置进行评估。对于MSAA，在所有四个位置都存储了单独的颜色和深度。右侧显示了EQAA的2f4x模式。这四个样本现在有四个ID值，它们索引存储的两种颜色和深度的表。

</div>

MSAA比纯超级采样方案更快，因为片段仅被着色一次。它专注于以更高的速率对片段的像素覆盖进行采样并共享计算出的着色。可以通过进一步解耦采样和覆盖来节省更多内存，这反过来可以使抗锯齿更快——占用的内存越少，渲染速度越快。NVIDIA于2006年推出了覆盖采样抗锯齿(CSAA)，AMD紧随其后推出了增强质量抗锯齿 (EQAA)。这些技术通过以更高的采样率仅存储片段的覆盖范围来工作。例如，EQAA的“2f4x”模式存储两个颜色和深度值，在四个采样位置之间共享。颜色和深度不再针对特定位置存储，而是保存在表格中。然后，四个样本中的每个样本只需要一位来指定两个存储值中的哪一个与其位置相关联。请参见图5.26。覆盖样本指定每个片段对最终像素颜色的贡献。如果超过了存储的颜色数量，存储的颜色将被驱逐，其样本被标记为未知。这些样本对最终颜色没有贡献 [382,383]。对于大多数场景，包含三个或更多可见不透明片段的像素相对较少，这些片段的着色完全不同，因此该方案在实践中表现良好[1405]。然而，为了获得最高质量，《极限竞速：地平线2》游戏采用4倍 MSAA，尽管EQAA具有性能优势[1002]。

将所有几何图形渲染到多样本缓冲区后，将执行解析操作。此过程将样本颜色平均在一起以确定像素的颜色。值得注意的是，在使用具有高动态范围颜色值的多重采样时可能会出现问题。在这种情况下，为避免伪影，你通常需要在解析[1375]之前对值进行色调映射。这可能会代价很高，因此可以使用对色调映射函数的更简单近似或其他方法[862,1405]。

默认情况下，MSAA使用box过滤器解析。2007年，ATI引入了自定义过滤器抗锯齿(CFAA)[1625]，能够使用稍微延伸到其他像素单元的窄和宽的tent过滤器。此后，此模式已被EQAA支持所取代。在现代GPU上，像素或计算着色器可以访问MSAA样本并使用所需的任何重建过滤器，包括从周围像素样本中采样的过滤器。更宽的过滤器可以减少混叠，但会丢失锐利的细节。Pettineo[1402,1405]发现，滤波器宽度为2或3像素的三次平滑步长和B样条滤波器总体上给出了最好的结果。还有性能成本，因为即使使用自定义着色器模拟默认box过滤器解析也需要更长的时间，并且更宽的过滤器内核意味着增加样本访问成本。

NVIDIA的内置TXAA支持类似地在比单个像素更广的区域上使用更好的重建过滤器，以提供更好的结果。它和较新的MFAA（多帧抗锯齿）方案都还使用时间抗锯齿 (TAA)，这是一种使用先前帧的结果来改善图像的通用技术。在某种程度上，由于允许程序员设置每帧的MSAA采样模式[1406]的功能，这种技术成为可能。此类技术可以解决诸如旋转车轮之类的锯齿问题，还可以提高边缘渲染质量。

想象一下，通过生成一系列图像来“手动”执行采样模式，其中每个渲染使用像素内的不同位置进行采样。这种偏移是通过在投影矩阵[1938]上附加一个微小的平移来完成的。一起生成和平均的图像越多，结果就越好。这种使用多个偏移图像的概念用于时间抗锯齿算法。可能使用MSAA或其他方法生成单个图像，然后将之前的图像混合在一起。通常只使用两到四帧[382,836,1405]。较旧的图像的权重可能会成倍减少[862]，尽管如果观看者和场景不移动，这可能会产生帧闪烁的效果，因此通常只对最后一帧和当前帧进行相等的加权。由于每一帧的样本位于不同的子像素位置，这些样本的加权和提供了比单帧更好的边缘覆盖率估计。因此，使用最新的两帧平均在一起的系统可以提供更好的结果。每帧都不需要额外的样本，这就是这种方法如此吸引人的原因。甚至可以使用时间采样来生成分辨率较低的图像，并将其放大到显示器的分辨率[1110]。此外，需要大量样本才能获得良好结果的照明方法或其他技术可以改为每帧使用更少的样本，因为结果将在多个帧上混合[1938]。

虽然在不增加采样成本的情况下为静态场景提供抗锯齿，但这种类型的算法在用于时间抗锯齿时存在一些问题。如果帧的权重不均等，则静态场景中的对象可能会出现微光。快速移动的对象或快速的相机移动可能会导致重影，即由于先前帧的贡献而在对象后面留下的痕迹。鬼影的一种解决方案是仅对缓慢移动的对象执行这种抗锯齿[1110]。另一个重要的方法是使用重投影（[第12.2节][netlink12.2]）来更好地关联前一帧和当前帧的对象。在这样的方案中，对象生成存储在单独的“速度缓冲区”中的运动矢量（[第12.5节][netlink12.5]）。这些向量用于将前一帧与当前帧相关联，即从当前像素位置减去该向量以找到该对象表面位置的前一帧颜色像素。样本不太可能是当前帧中表面的一部分被丢弃[1912]。由于时间抗锯齿不需要额外的样本，因此额外的工作相对较少，近年来这种算法引起了强烈的兴趣和广泛采用。这种关注部分是因为延迟着色技术（[第20.1节][netlink20.1]）与MSAA和其他多重采样支持不兼容[1486]。方法各不相同，并且根据应用程序的内容和目标，已经开发了一系列避免伪影和提高质量的技术[836,1154,1405,1533,1938]。例如，Wihlidal的演示文稿[1885]展示了应用于棋盘采样模式的EQAA、时间抗锯齿和各种过滤技术如何结合起来以保持质量，同时降低像素着色器调用的数量。伊格莱西亚斯-吉蒂安等人[796]总结了以前的工作并提出了他们的方案，以使用像素历史和预测来最小化过滤伪影。帕特尼等人[1357]扩展了Karis和Lottes在虚幻引擎4实现[862]上的TAA工作，以用于虚拟现实应用程序，添加可变大小的采样以及对眼球运动的补偿（[第21.3.2节][netlink21.3]）。

#### 采样模式

有效的采样模式是减少混叠、时间和其他方面的关键因素。Naiman[1257]表明，人类最容易受到近水平和近垂直边缘上的混叠的干扰。其次是倾斜度接近45度的边缘。旋转网格超级采样(RGSS)使用旋转的方形图案在像素内提供更高的垂直和水平分辨率。图5.25显示了这种模式的一个示例。

RGSS模式是拉丁超立方体或N-rooks采样的一种形式，其中n个样本放置在n×n网格中，每行和每列一个样本[1626]。使用RGSS，四个样本分别位于4×4子像素网格的单独行和列中。与常规的2×2采样模式相比，此类模式特别适用于捕获几乎水平和垂直的边缘，其中此类边缘可能覆盖偶数个样本，因此提供的有效级别较少。

N-rooks是创建良好采样模式的开始，但这还不够。例如，样本可能都位于子像素网格的对角线上，因此对于几乎平行于该对角线的边缘给出了较差的结果。参见图5.27。为了更好的采样，我们希望避免将两个样本放在一起。我们还想要一个均匀的分布，将样本均匀地分布在该区域上。为了形成这样的模式，分层抽样技术（如拉丁超立方抽样）与其他方法（如抖动、Halton序列和泊松盘抽样）相结合[1413,1758]。

<div align = "center">

![Figure5.27]

</div>

<div align = "center">

**图5.27**. N-rooks采样。左边是一个合法的N-rooks模式，但它在捕获沿其线对角线的三角形边缘方面表现不佳，因为随着该三角形的移动，所有样本位置都将位于三角形内部或外部。 右边是一个模式，可以更有效地捕捉这个边缘和其他边缘。

</div>

在实践中，GPU制造商通常将此类采样模式硬连接到他们的硬件中，以进行多重采样抗锯齿。图5.28显示了一些实际使用的MSAA模式。对于时间抗锯齿，覆盖模式是程序员想要的，因为样本位置可以逐帧变化。例如，Karis[862]发现基本Halton序列比GPU提供的任何MSAA模式效果更好。Halton序列在空间中生成的样本看起来是随机的，但差异很小，也就是说，它们在空间上分布良好，没有一个是聚类的[1413,1938]。

<div align = "center">

![Figure5.28]

</div>

<div align = "center">

**图5.28**. AMD和NVIDIA图形加速器的MSAA 采样模式。绿色方块是着色样本的位置，红色方块是计算和保存的位置样本。从左到右：2×、4×、6×（AMD）和8×（NVIDIA）采样。（由 D3D FSAA 查看器生成。）

</div>

虽然亚像素网格模式可以更好地近似每个三角形如何覆盖网格单元，但它并不理想。一个场景可以由屏幕上任意小的物体组成，这意味着没有任何采样率可以完美地捕捉它们。如果这些微小的物体或特征形成图案，则以恒定间隔进行采样会导致莫尔条纹和其他干涉图案。超级采样中使用的网格模式特别容易混叠。

一种解决方案是使用随机抽样，它提供了更随机的模式。像图5.28中的那些模式当然是合格的。想象一下远处有一把细齿梳子，每个像素都有几颗梳齿。当采样模式与梳齿频率同相和异相时，规则模式会产生严重的伪影。具有较少有序的采样模式可以打破这些模式。随机化倾向于用噪声代替重复的混叠效应，人类视觉系统对此更加宽容[1413]。结构较少的模式会有所帮助，但在逐个像素重复时仍会出现混叠。一种解决方案是在每个像素处使用不同的采样模式，或者随时间改变每个采样位置。交错采样索引采样交错，其中一组的每个像素具有不同的采样模式，在过去的几十年中偶尔在硬件中得到支持。例如，ATI的SMOOTHVISION允许每个像素最多16个样本和最多16种不同的用户定义的采样模式，这些模式可以混合在重复模式中（例如，在4×4像素块中）。Molnar[1234]以及Keller和Heidrich[880] 发现，使用交错随机采样可以最大限度地减少对每个像素使用相同模式时形成的混叠伪影。

其他一些GPU支持的算法值得注意。一种让样本影响多个像素的实时抗锯齿方案是NVIDIA较旧的Quincunx方法[365]。 “Quincunx”是指五个物体的排列，四个在一个正方形中，第五个在中心，例如六面骰子上的五个点的图案。Quincunx 多重采样抗锯齿使用这种模式，将四个外部样本放在像素的角点。请参见图5.25。每个角点样本值分布到其四个相邻像素。中心样本的权重为$\frac{1}{2}$ ，而每个角落样本的权重为$\frac{1}{8}$，而不是对每个样本进行同等加权（就像大多数其他实时方案所做的那样）。由于这种共享，每个像素平均只需要两个样本，结果明显优于两个样本FSAA 方法[1678]。这种模式近似于二维tent过滤器，如上一节所述，优于box过滤器。

Quincunx采样也可以通过每个像素使用单个样本来应用于时间抗锯齿[836,1677]。每帧在每个轴上从前一帧偏移半个像素，偏移方向在帧之间交替。前一帧提供像素角样本，双线性插值用于快速计算每个像素的贡献。结果是当前帧的平均值。每帧的权重相等意味着静态视图没有闪光伪影。对齐移动对象的问题仍然存在，但该方案本身编码简单，并且在每帧每个像素仅使用一个样本时提供了更好的外观。

在单帧中使用时，Quincunx通过在像素边界共享样本得到了很低的成本，只有两个样本。RGSS图案更擅长捕捉更多接近水平和垂直边缘的渐变。FLIPQUAD模式最初是为移动图形开发的，它结合了这两个理想的特征[22]。它的优点是成本仅为每个像素两个样本，质量类似于RGSS（每个像素成本四个样本）。这种采样模式如图5.29所示。Hasselgren等人探索了其他利用样本共享的廉价采样模式[677]。

<div align = "center">

![Figure5.29]

</div>

<div align = "center">

**图5.29**. 左侧显示了RGSS采样模式。这需要每个像素四个样本。通过将这些位置移到像素边缘，可以跨边缘进行样本共享。然而，为了解决这个问题，每个其他像素都必须有一个反射样本图案，如右图所示。生成的样本模式称为 FLIPQUAD，每个像素需要两个样本。

</div>

与Quincunx一样，双样本FLIPQUAD模式也可以与时间抗锯齿一起使用并分布在两个帧上。Drobot[382,383,1154]解决了在他的混合重建抗锯齿 (HRAA) 工作中哪种双样本模式最好的问题。他探索了时间抗锯齿的不同采样模式，发现FLIPQUAD模式是五种测试模式中最好的。棋盘模式也被用于时间抗锯齿。El Mansouri[415]讨论了使用两个样本的MSAA来创建棋盘渲染以降低着色器成本，同时解决混叠问题。Jimenez[836]使用SMAA、时间抗锯齿和各种其他技术来提供一种解决方案，其中抗锯齿质量可以响应渲染引擎负载而改变。Carpentier和Ishiyama[231]在边缘采样，将采样网格旋转45°。他们将这种时间抗锯齿方案与FXAA（稍后讨论）相结合，以有效地在更高分辨率的显示器上进行渲染。

#### 形态学方法

锯齿通常是由边缘引起的，例如由几何形状、锐利阴影或明亮高光形成的边缘。可以利用锯齿具有与之结构相关的知识来提供更好的抗锯齿结果。2009年，Reshetov[1483]提出了一种算法，称为形态学抗锯齿 (MLAA)。“形态学”的意思是“与结构或形状有关”。早在1983年，Bloomenthal[170]就已在该领域[830]进行了早期工作。Reshetov的论文重启了对多重采样方法替代方案的研究，强调搜索和重建边缘[1486]。

这种形式的抗锯齿是作为后处理执行的。也就是说，以通常的方式进行渲染，然后将结果馈送到生成抗锯齿结果的进程。自2009年以来，已经开发了广泛的技术。那些依赖于额外缓冲区（例如深度和法线）的技术可以提供更好的结果，例如亚像素重建抗锯齿 (SRAA) [43,829]，但随后仅适用于几何边缘的抗锯齿。分析方法，例如几何缓冲区抗锯齿(GBAA)和距离到边缘抗锯齿(DEAA)，让渲染器计算有关三角形边缘所在位置的附加信息，例如，边缘距像素中心的距离[829]。

最通用的方案只需要颜色缓冲区，这意味着它们还可以改善阴影、高光或各种先前应用的后处理技术的边缘，例如轮廓边缘渲染（[第15.2.3节][netlink15.2]）。例如，定向局部抗锯齿 (DLAA)[52,829]是基于这样的观察，即几乎垂直的边缘应该水平模糊，同样接近水平的边缘应该与其邻居垂直模糊。

更精细的边缘检测形式试图找到可能包含任何角度边缘的像素并确定其覆盖范围。检查潜在边缘周围的邻域，目的是尽可能重建原始边缘所在的位置。然后可以使用边缘对像素的影响来混合相邻像素的颜色。有关该过程的概念视图，请参见图5.30。

<div align = "center">

![Figure5.30]

</div>

<div align = "center">

**图5.30**. 形态学抗锯齿。左侧是锯齿图像。目标是确定形成它的边缘的可能方向。在中间，该算法通过检查领域来记录边缘的可能性。给定样本，显示了两个可能的边缘位置。在右侧，最佳猜测边缘用于将相邻颜色与估计的覆盖率成比例地混合到中心像素中。对图像中的每个像素重复此过程。

</div>

Iourcha等人[798]通过检查以像素为单位的MSAA样本来改进边缘查找，以计算更好的结果。请注意，边缘预测和混合可以提供比基于样本的算法更高精度的结果。例如，每像素使用四个样本的技术只能为对象边缘提供五个级别的混合：不覆盖样本、覆盖一个、两个、三个和四个。估计的边缘位置可以有更多位置，因此可以提供更好的结果。

基于图像的算法有几种误入歧途的方式。首先，如果两个对象之间的色差低于算法的阈值，则可能无法检测到边缘。三个或更多不同表面重叠的像素很难解析。具有高对比度或高频元素的表面，颜色在像素之间快速变化，可能会导致算法丢失边缘。特别是，当对其应用形态抗锯齿时，文本质量通常会受到影响。对象角可能是一个挑战，一些算法赋予它们圆润的外观。曲线也可能受到边缘是直的假设的不利影响。单个像素的变化会导致边缘重建方式发生很大变化，这可能会在帧与帧之间产生明显的伪影。改善这个问题的一种方法是使用MSAA覆盖掩码来改进边缘确定[1484]。

形态抗锯齿方案仅使用提供的信息。例如，宽度小于像素的对象（例如电线或绳索）将在屏幕上出现间隙，只要它没有恰好覆盖像素的中心位置。在这种情况下，采取更多的样本可以提高质量；仅基于图像的抗锯齿不能。此外，执行时间可以根据查看的内容而变化。例如，一片草地的抗锯齿时间可能是天空视图的三倍 [231]。

尽管如此，基于图像的方法可以为适度的内存和处理成本提供抗锯齿支持，因此它们被用于许多应用程序中。仅颜色版本也与渲染管道分离，使其易于修改或禁用，甚至可以作为GPU驱动程序选项公开。两种最流行的算法是快速近似抗锯齿(FXAA)[1079,1080,1084]和亚像素形态抗锯齿(SMAA)[828,830,834]，部分原因是两者都为各种机器提供了可靠的（和免费的）源代码实现。两种算法都使用纯颜色输入，SMAA具有能够访问MSAA样本的优势。每个都有自己的各种可用设置，在速度和质量之间进行权衡。成本通常在每帧1到2毫秒的范围内，主要是因为这是视频游戏愿意花费的。最后，这两种算法还可以利用时间抗锯齿[1812]。Jimenez[836]提出了一种改进的SMAA实现，比FXAA更快，并描述了一种时间抗锯齿方案。最后，我们建议读者阅读Reshetov和Jimenez[1486]对形态学技术及其在视频游戏中的应用的广泛评述。

[netlink6.0]:netlink6.0
[netlink6.2]:netlink6.2
[netlink12.1]:netlink12.1
[netlink12.2]:netlink12.2
[netlink12.5]:netlink12.5
[netlink15.2]:netlink15.2
[netlink20.1]:netlink20.1
[netlink21.3]:netlink21.3

[Figure5.14]:Figure/Figure5.14.JPG
[Figure5.15]:Figure/Figure5.15.JPG
[Figure5.16]:Figure/Figure5.16.JPG
[Figure5.17]:Figure/Figure5.17.JPG
[Figure5.18]:Figure/Figure5.18.JPG
[Figure5.19]:Figure/Figure5.19.JPG
[Figure5.20]:Figure/Figure5.20.JPG
[Figure5.21]:Figure/Figure5.21.JPG
[Figure5.22]:Figure/Figure5.22.JPG
[Figure5.23]:Figure/Figure5.23.JPG
[Figure5.24]:Figure/Figure5.24.JPG
[Figure5.25]:Figure/Figure5.25.JPG
[Figure5.26]:Figure/Figure5.26.JPG
[Figure5.27]:Figure/Figure5.27.JPG
[Figure5.28]:Figure/Figure5.28.JPG
[Figure5.29]:Figure/Figure5.29.JPG
[Figure5.30]:Figure/Figure5.30.JPG